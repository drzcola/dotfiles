/***************************************************************************
*                           STAR WARS REALITY 1.0                          *
*--------------------------------------------------------------------------*
* Star Wars Reality Code Additions and changes from the Smaug Code         *
* copyright (c) 1997 by Sean Cooper                                        *
* -------------------------------------------------------------------------*
* Starwars and Starwars Names copyright(c) Lucas Film Ltd.                 *
*--------------------------------------------------------------------------*
* SMAUG 1.0 (C) 1994, 1995, 1996 by Derek Snider                           *
* SMAUG code team: Thoric, Altrag, Blodkai, Narn, Haus,                    *
* Scryn, Rennard, Swordbearer, Gorog, Grishnakh and Tricops                *
* ------------------------------------------------------------------------ *
* Merc 2.1 Diku Mud improvments copyright (C) 1992, 1993 by Michael        *
* Chastain, Michael Quan, and Mitchell Tse.                                *
* Original Diku Mud copyright (C) 1990, 1991 by Sebastian Hammer,          *
* Michael Seifert, Hans Henrik St{rfeldt, Tom Madsen, and Katja Nyboe.     *
* ------------------------------------------------------------------------ *
*			     Informational module			                                       *
****************************************************************************/

#include <sys/types.h>
#include <ctype.h>
#include <stdio.h>
#include <string.h>
#include <time.h>
#include <unistd.h>
#include <math.h>
#include "mud.h"
#include "sha256.h"

/*
 * Keep players from defeating examine progs -Druid
 * False = do not trigger
 * True = Trigger
 */
bool EXA_prog_trigger = TRUE;

ROOM_INDEX_DATA *generate_exit( ROOM_INDEX_DATA *in_room, EXIT_DATA **pexit );

/*
 * Local functions.
 */
void	show_char_to_char_0	args( ( CHAR_DATA *victim, CHAR_DATA *ch ) );
void	show_char_to_char_1	args( ( CHAR_DATA *victim, CHAR_DATA *ch ) );
void	show_char_to_char	args( ( CHAR_DATA *list, CHAR_DATA *ch ) );
void	show_ships_to_char	args( ( SHIP_DATA *ship, CHAR_DATA *ch ) );
bool	check_blind		args( ( CHAR_DATA *ch ) );
void    show_condition          args( ( CHAR_DATA *ch, CHAR_DATA *victim ) );


char *format_obj_to_char( OBJ_DATA *obj, CHAR_DATA *ch, bool fShort )
{
    static char buf[MAX_STRING_LENGTH];
	bool glowsee = FALSE;

	/*
    * can see glowing invis items in the dark
    */
   if( IS_OBJ_STAT( obj, ITEM_GLOW ) && IS_OBJ_STAT( obj, ITEM_INVIS )
       && !IS_AFFECTED( ch, AFF_TRUESIGHT ) && !IS_AFFECTED( ch, AFF_DETECT_INVIS ) )
      glowsee = TRUE;

    buf[0] = '\0';
	if (IS_MAKINGJOB(ch) && ch->pcdata->jobdata->state == JOB_ACCEPTED &&
		(obj->pIndexData->vnum == ch->pcdata->jobdata->obj1 ||
		obj->pIndexData->vnum == ch->pcdata->jobdata->obj2))
			strcat(buf, "&w[&ROBJETIVO&w] ");
    if ( IS_OBJ_STAT(obj, ITEM_INVIS)     )   strcat( buf, "(Invis) "     );
	if ( IS_OBJ_MAGIC(obj, ITEM_IMPLANTED) )   strcat( buf, "(Implantado) ");
    if ( ( IS_AFFECTED(ch, AFF_DETECT_MAGIC) || IS_IMMORTAL(ch) )
	 && IS_OBJ_STAT(obj, ITEM_MAGIC)  )   strcat( buf, "&B(Aura azul)&w "   );
    if ( !glowsee && IS_OBJ_STAT(obj, ITEM_GLOW)      )   strcat( buf, "(Brillante) "   );
    if ( IS_OBJ_STAT(obj, ITEM_HUM)       )   strcat( buf, "(Humeante) "   );
    if ( IS_OBJ_STAT(obj, ITEM_HIDDEN)	  )   strcat( buf, "(Escondido) "	  );
    if ( IS_OBJ_STAT(obj, ITEM_BURRIED)	  )   strcat( buf, "(Enterrado) "	  );
	if ( obj->item_type == ITEM_ARMORMETAL   )   strcat( buf, "&w"	);
	if ( obj->item_type == ITEM_ARMORTELA	  )	  strcat( buf, "&w" );
	if ( obj->item_type == ITEM_ARMOROTRO	)	strcat( buf, "&w" );
	if ( obj->item_type == ITEM_TRASH 	  )   strcat( buf, "&w"	);
	if ( obj->item_type == ITEM_LIGHT 	  )   strcat( buf, "&w"	);
	if ( obj->item_type == ITEM_WEAPON 	  )   strcat( buf, "&w"	);
	if ( obj->item_type == ITEM_CONTAINER	  )   strcat( buf, "&w"	);
	if ( obj->item_type == ITEM_COMLINK	 )   strcat( buf, "&w"	);
	if ( obj->item_type == ITEM_BATTERY 	  )   strcat( buf, "&w"	);
	if ( obj->item_type == ITEM_SALVE 	  )   strcat( buf, "&C"	);
	if ( obj->item_type == ITEM_PILL 	  )   strcat( buf, "&C"	);
	if ( obj->item_type == ITEM_POTION 	  )   strcat( buf, "&C"	);
	if ( obj->item_type == ITEM_INJECTABLE 	  )   strcat( buf, "&C"	);
	if ( obj->item_type == ITEM_FURNITURE 	  )   strcat( buf, "&w"	);//-*Larias*
    if ( IS_IMMORTAL(ch)
	 && IS_OBJ_STAT(obj, ITEM_PROTOTYPE) ) strcat( buf, "(PROTO) "	  );
    if ( IS_AFFECTED(ch, AFF_DETECTTRAPS)
	 && is_trapped(obj)   )   strcat( buf, "(Trampa) "  );

	if( fShort ) {
      if( glowsee && ( IS_NPC( ch ) || !IS_SET( ch->act, PLR_HOLYLIGHT ) ) )
         strcpy( buf, "the faint glow of something");
      else if( obj->short_descr )
         strcat( buf, obj->short_descr );
   }
   else {
      if( glowsee && ( IS_NPC( ch ) || !IS_SET( ch->act, PLR_HOLYLIGHT ) ) )
         strcpy( buf, "You see the faint glow of something nearby.");
      else if( obj->description )
         strcat( buf, obj->description );
   }
    return buf;
}


/*
 * Some increasingly freaky halucinated objects		-Thoric
 */
char *halucinated_object( int ms, bool fShort )
{
    int sms = URANGE( 1, (ms+10)/5, 20 );

    if ( fShort )
    switch( number_range( 6-URANGE(1,sms/2,5), sms ) )
    {
	case  1: return "una pistola";
	case  2: return "un palo";
	case  3: return "algo brillante";
	case  4: return "algo";
	case  5: return "algo interesante";
	case  6: return "algo de colores";
	case  7: return "algo con buena pinta";
	case  8: return "una cosa ingeniosa";
	case  9: return "una capa de colores";
	case 10: return "una mística espada en llamas";
	case 11: return "un enjambre de insectos";
	case 12: return "a deathbane (?)";
	case 13: return "un fragmento de tu imaginación";
	case 14: return "tu tumba";
	case 15: return "las botas perdidas de Ranger Thoric";
	case 16: return "el código de un programa indescifrable";
	case 17: return "un secreto largamente anhelado";
	case 18: return "el significado de todo";
	case 19: return "la respuesta";
	case 20: return "la clave de la vida, el universo y todo";
    }
    switch( number_range( 6-URANGE(1,sms/2,5), sms ) )
    {
	case  1: return "Una buena pistola se clava en tus ojos.";
	case  2: return "El suelo está cubierto de pequeños palos.";
	case  3: return "Algo brillante te llama la atención.";
	case  4: return "Algo llama tu atención.";
	case  5: return "Algo interesante desvía tu mirada .";
	case  6: return "Algo fluye en colores.";
	case  7: return "Algo que tiene muy buena pinta te está llamando.";
	case  8: return "A nifty thing of great importance stands here.";
	case  9: return "Una capa de colores te pide que la vistas.";
	case 10: return "Una espada en llamas está esperando que la empuñes.";
	case 11: return "Un enjambre de insectos zumba en tu cara!";
	case 12: return "( que es deathbane?)The extremely rare Deathbane lies at your feet.";
	case 13: return "Un fragmento de tu imaginación espera tus ordenes.";
	case 14: return "Descubres una lápida aquí... miras con detenimiento ¡y ves tu nombre en ella!";
	case 15: return "Las botas perdidas de Ranger Thoric están ahí.";
	case 16: return "El código de un programa indescifrable se hace inteligible para ti.";
	case 17: return "Un secreto muy anhelado es ahora evidente para ti.";
	case 18: return "El significado de todo, tan simple, tan claro... por supuesto!";
	case 19: return "La respuesta.  Uno.  Siempre ha sido Uno.";
	case 20: return "La clave de la vida, del universo y de todo está en tu mano.";
    }
    return "¡¡¡Whuaw!!!";
}


/*
 * Show a list to a character.
 * Can coalesce duplicated items.
 */
void show_list_to_char( OBJ_DATA *list, CHAR_DATA *ch, bool fShort, bool fShowNothing )
{
    char **prgpstrShow;
    int *prgnShow;
    int *pitShow;
    char *pstrShow;
    OBJ_DATA *obj;
    int nShow;
    int iShow;
    int count, offcount, tmp, ms, cnt;
    bool fCombine;

    if ( !ch->desc )
	return;

    /*
     * if there's no list... then don't do all this crap!  -Thoric
     */
    if ( !list )
    {
    	if ( fShowNothing )
    	{
	   if ( IS_NPC(ch) || IS_SET(ch->act, PLR_COMBINE) )
	      send_to_char( "     ", ch );
	   send_to_char( "Nada.\n\r", ch );
	}
	return;
    }
    /*
     * Alloc space for output lines.
     */
    count = 0;
    for ( obj = list; obj; obj = obj->next_content )
	count++;

    ms  = (ch->mental_state ? ch->mental_state : 1)
	* (IS_NPC(ch) ? 1 : (ch->pcdata->condition[COND_DRUNK] ? (ch->pcdata->condition[COND_DRUNK]/12) : 1));

    /*
     * If not mentally stable...
     */
    if ( abs(ms) > 40 )
    {
	offcount = URANGE( -(count), (count * ms) / 100, count*2 );
	if ( offcount < 0 )
	  offcount += number_range(0, abs(offcount));
	else
	if ( offcount > 0 )
	  offcount -= number_range(0, offcount);
    }
    else
	offcount = 0;

    if ( count + offcount <= 0 )
    {
    	if ( fShowNothing )
    	{
	   if ( IS_NPC(ch) || IS_SET(ch->act, PLR_COMBINE) )
	      send_to_char( "     ", ch );
	   send_to_char( "Nada.\n\r", ch );
	}
	return;
    }

    CREATE( prgpstrShow,	char*,	count + ((offcount > 0) ? offcount : 0) );
    CREATE( prgnShow,		int,	count + ((offcount > 0) ? offcount : 0) );
    CREATE( pitShow,		int,	count + ((offcount > 0) ? offcount : 0) );
    nShow	= 0;
    tmp		= (offcount > 0) ? offcount : 0;
    cnt		= 0;

    /*
     * Format the list of objects.
     */
    for ( obj = list; obj; obj = obj->next_content )
    {
	if ( offcount < 0 && ++cnt > (count + offcount) )
	    break;
	if ( tmp > 0 && number_bits(1) == 0 )
	{
	    prgpstrShow [nShow] = str_dup( halucinated_object(ms, fShort) );
	    prgnShow	[nShow] = 1;
	    pitShow	[nShow] = number_range( ITEM_LIGHT, ITEM_BOOK );
	    nShow++;
	    --tmp;
	}
	if ( obj->wear_loc == WEAR_NONE
	&& can_see_obj( ch, obj )
	&& (obj->item_type != ITEM_TRAP || IS_AFFECTED(ch, AFF_DETECTTRAPS) ))
	{
	    pstrShow = format_obj_to_char( obj, ch, fShort );
	    fCombine = FALSE;

	    if ( IS_NPC(ch) || IS_SET(ch->act, PLR_COMBINE) )
	    {
		/*
		 * Look for duplicates, case sensitive.
		 * Matches tend to be near end so run loop backwords.
		 */
		for ( iShow = nShow - 1; iShow >= 0; iShow-- )
		{
		    if ( !strcmp( prgpstrShow[iShow], pstrShow ) )
		    {
			prgnShow[iShow] += obj->count;
			fCombine = TRUE;
			break;
		    }
		}
	    }

	    pitShow[nShow] = obj->item_type;
	    /*
	     * Couldn't combine, or didn't want to.
	     */
	    if ( !fCombine )
	    {
		prgpstrShow [nShow] = str_dup( pstrShow );
		prgnShow    [nShow] = obj->count;
		nShow++;
	    }
	}
    }
    if ( tmp > 0 )
    {
	int x;
	for ( x = 0; x < tmp; x++ )
	{
	    prgpstrShow [nShow] = str_dup( halucinated_object(ms, fShort) );
	    prgnShow	[nShow] = 1;
	    pitShow	[nShow] = number_range( ITEM_LIGHT, ITEM_BOOK );
	    nShow++;
	}
    }

    /*
     * Output the formatted list.		-Color support by Thoric
     */
    for ( iShow = 0; iShow < nShow; iShow++ )
    {
	switch(pitShow[iShow]) {
	default:
	  set_char_color( AT_OBJECT, ch );
	  break;
	case ITEM_BLOOD:
	  set_char_color( AT_BLOOD, ch );
	  break;
	case ITEM_MONEY:
	case ITEM_TREASURE:
	  set_char_color( AT_YELLOW, ch );
	  break;
	case ITEM_FOOD:
	  set_char_color( AT_HUNGRY, ch );
	  break;
	case ITEM_DRINK_CON:
	case ITEM_FOUNTAIN:
	  set_char_color( AT_THIRSTY, ch );
	  break;
	case ITEM_FIRE:
	  set_char_color( AT_FIRE, ch );
	  break;
	case ITEM_SCROLL:
	case ITEM_WAND:
	case ITEM_STAFF:
	  set_char_color( AT_MAGIC, ch );
	  break;
	}
	if ( fShowNothing )
	    send_to_char( "     ", ch );
	send_to_char( prgpstrShow[iShow], ch );
/*	if ( IS_NPC(ch) || IS_SET(ch->act, PLR_COMBINE) ) */
	{
	    if ( prgnShow[iShow] != 1 )
		ch_printf( ch, " (%d)", prgnShow[iShow] );
	}

	send_to_char( "\n\r", ch );
	DISPOSE( prgpstrShow[iShow] );
    }

    if ( fShowNothing && nShow == 0 )
    {
	if ( IS_NPC(ch) || IS_SET(ch->act, PLR_COMBINE) )
	    send_to_char( "     ", ch );
	send_to_char( "Nada.\n\r", ch );
    }

    /*
     * Clean up.
     */
    DISPOSE( prgpstrShow );
    DISPOSE( prgnShow	 );
    DISPOSE( pitShow	 );
    return;
}


/*
 * Show fancy descriptions for certain spell affects		-Thoric
 */
void show_visible_affects_to_char( CHAR_DATA *victim, CHAR_DATA *ch )
{
    char buf[MAX_STRING_LENGTH];

    if ( IS_AFFECTED(victim, AFF_SANCTUARY) )
    {
        if ( IS_GOOD(victim) )
        {
            set_char_color( AT_WHITE, ch );
            ch_printf( ch, "%s brilla con un aura divina.\n\r",
		IS_NPC( victim ) ? capitalize(victim->short_descr) : (victim->name) );
        }
        else if ( IS_EVIL(victim) )
        {
            set_char_color( AT_WHITE, ch );
            ch_printf( ch, "%s desprende un aura de energía oscura.\n\r",
		IS_NPC( victim ) ? capitalize(victim->short_descr) : (victim->name) );
        }
        else
        {
            set_char_color( AT_WHITE, ch );
            ch_printf( ch, "%s está rodeado por un flujo de sombras y luces.\n\r",
		IS_NPC( victim ) ? capitalize(victim->short_descr) : (victim->name) );
        }
    }
    if ( IS_AFFECTED(victim, AFF_FIRESHIELD) )
    {
        set_char_color( AT_FIRE, ch );
        ch_printf( ch, "%s está envuelto en llamas místicas.\n\r",
	    IS_NPC( victim ) ? capitalize(victim->short_descr) : (victim->name) );
    }
    if ( IS_AFFECTED(victim, AFF_SHOCKSHIELD) )
    {
        set_char_color( AT_BLUE, ch );
	ch_printf( ch, "%s está rodeado de un torrente de energía eléctrica.\n\r",
	    IS_NPC( victim ) ? capitalize(victim->short_descr) : (victim->name) );
    }
/*Scryn 8/13*/
    if ( IS_AFFECTED(victim, AFF_ICESHIELD) )
    {
        set_char_color( AT_LBLUE, ch );
        ch_printf( ch, "%s está dentro de una esfera de cristales de hielo.\n\r",
	    IS_NPC( victim ) ? capitalize(victim->short_descr) : (victim->name) );
    }/*
    if ( IS_AFFECTED(victim, AFF_CHARM)       )
    {
	set_char_color( AT_MAGIC, ch );
	ch_printf( ch, "%s parece no tener expresión alguna.\n\r",
	    IS_NPC( victim ) ? capitalize(victim->short_descr) : (victim->name) );
    }*/
    if ( !IS_NPC(victim) && !victim->desc
    &&    victim->switched && IS_AFFECTED(victim->switched, AFF_POSSESS) )
    {
	set_char_color( AT_MAGIC, ch );
	strcpy( buf, PERS( victim, ch ) );
	strcat( buf, " parece estar en un profundo trance...\n\r" );
    }
}

void show_char_to_char_0( CHAR_DATA *victim, CHAR_DATA *ch )
{
	char buf[MAX_STRING_LENGTH];
	char buf1[MAX_STRING_LENGTH];
	char message[MAX_STRING_LENGTH]; /* Output for the furniture -- Xerves */

	buf[0] = '\0';

	if ( IS_NPC(victim) )
		strcat( buf, " "  );
	if (IS_NPC(victim) && IS_MAKINGJOB(ch) && ch->pcdata->jobdata->state == JOB_ACCEPTED &&
		(victim->pIndexData->vnum == ch->pcdata->jobdata->mob1 ||
		 victim->pIndexData->vnum == ch->pcdata->jobdata->mob2))
		strcat( buf, "&w[&ROBJETIVO&w] ");
	if ( !IS_NPC(victim) && !victim->desc )
	{
		if ( !victim->switched )		strcat( buf, "(Sin Conexión) "  );
		else
			if ( !IS_AFFECTED(victim->switched, AFF_POSSESS) )
			strcat( buf, "(Switch) " );
	}
	if ( !IS_NPC(victim)
		&& IS_SET(victim->act, PLR_AFK) )		strcat( buf, "[AFK] ");

	if ( (!IS_NPC(victim) && IS_SET(victim->act, PLR_WIZINVIS))
		|| (IS_NPC(victim) && IS_SET(victim->act, ACT_MOBINVIS)) )
	{
		if (!IS_NPC(victim))
			sprintf( buf1,"(Invis %d) ", victim->pcdata->wizinvis );
		else sprintf( buf1,"(Mobinvis %d) ", victim->mobinvis);
		strcat( buf, buf1 );
	}

	if ( IS_AFFECTED(victim, AFF_INVISIBLE)   ) strcat( buf, "(Invis) "      );
	if ( IS_AFFECTED(victim, AFF_HIDE)        ) strcat( buf, "(Escondido) "       );
	if ( IS_AFFECTED(victim, AFF_PASS_DOOR)   ) strcat( buf, "(Traslucido) ");
	if ( IS_AFFECTED(victim, AFF_FAERIE_FIRE) ) strcat( buf, "&P(Aura Rosa)&D "  );
	if ( IS_EVIL(victim)
		&&   IS_AFFECTED(ch, AFF_DETECT_EVIL)     ) strcat( buf, "&R(Aura Roja)&D "   );
	if ( !IS_NPC(victim) && IS_SET(victim->act, PLR_LITTERBUG  ) )
		strcat( buf, "(LITTERBUG) "  );
	if ( IS_NPC(victim) && IS_IMMORTAL(ch)
		&& IS_SET(victim->act, ACT_PROTOTYPE) ) strcat( buf, "(PROTO) " );
	if ( victim->desc && victim->desc->connected == CON_EDITING )
		strcat( buf, "(Escribiendo) " );

	set_char_color( AT_PERSON, ch );
	if ( victim->position == victim->defposition && victim->long_descr[0] != '\0' )
	{
		strcat( buf, victim->long_descr );
		send_to_char( buf, ch );
		show_visible_affects_to_char( victim, ch );
		return;
	}

	/*   strcat( buf, PERS( victim, ch ) );       old system of titles
	 *    removed to prevent prepending of name to title     -Kuran
	 *
	 *    But added back bellow so that you can see mobs too :P   -Durga
	 */

	if ( !IS_NPC(victim) && !IS_SET(ch->act, PLR_BRIEF) )
		strcat( buf, victim->pcdata->title );
	else
		strcat( buf, PERS( victim, ch ) );

	switch ( victim->position )
	{
		case POS_DEAD:     strcat( buf, "&g está MUERTO!!" );			break;
		case POS_MORTAL:   strcat( buf, "&g está mortalmente herido." );		break;
		case POS_INCAP:    strcat( buf, "&g está incapacitado." );		break;
		case POS_STUNNED:  strcat( buf, "&g está tumbado aturdido." );	break;
		/* Furniture ideas taken from ROT
		 Furniture 1.01 is provided by Xerves
		 Info rewrite for sleeping/resting/standing/sitting on Objects -- Xerves */
		case POS_SLEEPING:
			if (victim->on != NULL)
		{
			if (IS_SET(victim->on->value[2],SLEEP_AT))
			{
				sprintf(message,"&g está durmiendo junto a %s.",
						victim->on->short_descr);
				strcat(buf,message);
			}
			else if (IS_SET(victim->on->value[2],SLEEP_ON))
			{
				sprintf(message,"&g está durmiendo encima de %s.",
						victim->on->short_descr);
				strcat(buf,message);
			}
			else
			{
				sprintf(message, "&g está durmiento dentro de %s.",
						victim->on->short_descr);
				strcat(buf,message);
			}
		}
			else
		{
			if (ch->position == POS_SITTING
				||  ch->position == POS_RESTING )
				strcat( buf, "&g está durmiendo cerca." );
			else
				strcat( buf, "&g está dormido como un tronco." );
		}
			break;
		case POS_RESTING:
			if (victim->on != NULL)
		{
			if (IS_SET(victim->on->value[2],REST_AT))
			{
				sprintf(message,"&g está descansando junto a %s.",
						victim->on->short_descr);
				strcat(buf,message);
			}
			else if (IS_SET(victim->on->value[2],REST_ON))
			{
				sprintf(message,"&g está descansando encima de %s.",
						victim->on->short_descr);
				strcat(buf,message);
			}
			else
			{
				sprintf(message, "&g está descansando dentro de %s.",
						victim->on->short_descr);
				strcat(buf,message);
			}
		}
			else
		{
			if (ch->position == POS_RESTING)
				strcat ( buf, "&g está descansando a tu lado." );
			else
				if (ch->position == POS_MOUNTED)
				strcat ( buf, "&g está descansando a los pies de tu montura." );
			else
				strcat (buf, "&g está tumbado descansando." );
		}
			break;
		case POS_SITTING:
			if (victim->on != NULL)
		{
			if (IS_SET(victim->on->value[2],SIT_AT))
			{
				sprintf(message,"&g está sentado junto a %s.",
						victim->on->short_descr);
				strcat(buf,message);
			}
			else if (IS_SET(victim->on->value[2],SIT_ON))
			{
				sprintf(message,"&g está sentado encima de %s.",
						victim->on->short_descr);
				strcat(buf,message);
			}
			else
			{
				sprintf(message, "&g está sentado dentro de %s.",
						victim->on->short_descr);
				strcat(buf,message);
			}
		}
			else
				strcat(buf, "&g está sentado aquí.");
			break;
		case POS_STANDING:
			if (victim->on != NULL)
		{
			if (IS_SET(victim->on->value[2],STAND_AT))
			{
				sprintf(message,"&g está de pie junto a %s.",
						victim->on->short_descr);
				strcat(buf,message);
			}
			else if (IS_SET(victim->on->value[2],STAND_ON))
			{
				sprintf(message,"&g está de pie encima de %s.",
						victim->on->short_descr);
				strcat(buf,message);
			}
			else
			{
				sprintf(message, "&g está de pie dentro de %s.",
						victim->on->short_descr);
				strcat(buf,message);
			}
		}
			else
				if ( IS_IMMORTAL(victim) )
				strcat( buf, "&g está aquí delante tuyo." );
			else
				if ( ( victim->in_room->sector_type == SECT_UNDERWATER )
					&& !IS_AFFECTED(victim, AFF_AQUA_BREATH) && !IS_NPC(victim) )
				strcat( buf, "&g se está ahogando." );
			else
				if ( victim->in_room->sector_type == SECT_UNDERWATER )
				strcat( buf, "&g está dentro del agua." );
			else
				if ( ( victim->in_room->sector_type == SECT_OCEANFLOOR )
					&& !IS_AFFECTED(victim, AFF_AQUA_BREATH) && !IS_NPC(victim) )
				strcat( buf, "&g se está ahogando." );
			else
				if ( victim->in_room->sector_type == SECT_OCEANFLOOR )
				strcat( buf, "&g está dentro del agua." );
			else
				if ( IS_AFFECTED(victim, AFF_FLOATING)
					|| IS_AFFECTED(victim, AFF_FLYING) )
				strcat( buf, "&g está suspenso en el aire." );
			else
				strcat( buf, "&g está aquí de pie." );
			break;



			case POS_SHOVE:    strcat( buf, "&g está siendo empujado." );	break;
			case POS_DRAG:     strcat( buf, "&g está siendo arrastrado." );	break;
		case POS_MOUNTED:
			strcat( buf, "&g está aquí, arriba. " );
			if ( !victim->mount )
				strcat( buf, "&gal aire???" );
			else
				if ( victim->mount == ch )
				strcat( buf, "&gtu espalda." );
			else
				if ( victim->in_room == victim->mount->in_room )
		{
			strcat( buf, PERS( victim->mount, ch ) );
			strcat( buf, "." );
		}
			else
				strcat( buf, "&galguien que se fue??" );
			break;
		case POS_FIGHTING:
			strcat( buf, "&g está aquí luchando " );
			if ( !victim->fighting )
				strcat( buf, "&gal aire???" );
			else if ( who_fighting( victim ) == ch )
				strcat( buf, "&gCONTIGO!" );
			else if ( victim->in_room == victim->fighting->who->in_room )
		{
			strcat( buf, PERS( victim->fighting->who, ch ) );
			strcat( buf, "." );
		}
			else
				strcat( buf, "&galguien que se fue??" );
			break;
	}

	strcat( buf, "\n\r" );
	buf[0] = toupper(buf[0]);
	send_to_char( buf, ch );
	show_visible_affects_to_char( victim, ch );
	return;
}



void show_char_to_char_1( CHAR_DATA *victim, CHAR_DATA *ch )
{
    OBJ_DATA *obj;
    int iWear;
    bool found;

    if ( can_see( victim, ch ) )
    {
    act( AT_ACTION, "$n te mira.", ch, NULL, victim, TO_VICT    );
    act( AT_ACTION, "$n mira a $N.",  ch, NULL, victim, TO_NOTVICT );
    }

    if ( victim->description[0] != '\0' )
    {
	send_to_char( "&c", ch );//default color for descriptions - Larias
	send_to_char( victim->description, ch );
    }
    else
    {
    act( AT_PLAIN, "No ves nada especial en $E.", ch, NULL, victim, TO_CHAR );
    }

    show_condition( ch, victim );

    found = FALSE;
    //for ( iWear = 0; iWear < IMPLANT_FIRST; iWear++ ) //newwear
	for (iWear = 0; iWear < get_implant_first(victim); iWear++)
    {
	if ( ( obj = get_eq_char2( victim, iWear ) ) != NULL
	&&   can_see_obj( ch, obj ) )
	{
	    if ( !found )
	    {
		send_to_char( "\n\r", ch );
		act( AT_PLAIN, "$N está usando:", ch, NULL, victim, TO_CHAR );
		found = TRUE;
	    }
	    send_to_char( wear_table[UMIN(victim->race,MAX_RACE)].where_name[iWear], ch );
	    send_to_char( format_obj_to_char( obj, ch, TRUE ), ch );
	    send_to_char( "\n\r", ch );
	}
    }

    found = FALSE;
    //for ( iWear = IMPLANT_FIRST; iWear < MAX_WEAR; iWear++ ) // newwear
	for ( iWear = get_implant_first(victim); iWear < get_max_wear(victim); iWear++ )
    {
    if ( ( obj = get_eq_char2( victim, iWear ) ) != NULL
    &&  can_see_obj( ch, obj ) )
    {
        if ( !found )
        {
        send_to_char( "\n\r", ch);
        act( AT_PLAIN, "$N tiene implantado:", ch, NULL, victim, TO_CHAR );
        found = TRUE;
        }
        send_to_char( wear_table[UMIN(victim->race,MAX_RACE)].where_name[iWear], ch );
        send_to_char( format_obj_to_char( obj, ch, TRUE ), ch );
        send_to_char( "\n\r", ch );
    }
    }

    /*
     * Crash fix here by Thoric
     */
    if ( IS_NPC(ch) || victim == ch )
      return;

    if ( number_percent( ) < ch->pcdata->learned[gsn_peek] )
    {
	send_to_char( "\n\rEchas un vistazo a su inventario:\n\r", ch );
	show_list_to_char( victim->first_carrying, ch, TRUE, TRUE );
	learn_from_success( ch, gsn_peek );
    }
    else
      if ( ch->pcdata->learned[gsn_peek] )
        learn_from_failure( ch, gsn_peek );

    return;
}


void show_char_to_char( CHAR_DATA *list, CHAR_DATA *ch )
{
    CHAR_DATA *rch;

    for ( rch = list; rch; rch = rch->next_in_room )
    {
	if ( rch == ch )
	    continue;

	// quitar esto
	if (!ch->in_room)
		bug("show_char_to_char: ch->in_room null");
	//
	if ( can_see( ch, rch ) )
	{
	    show_char_to_char_0( rch, ch );
	}
//	else if ( rch->race == RACE_DEFEL )
//	{
//	    set_char_color( AT_BLOOD, ch );
//	    send_to_char( "Ves un par de ojos rojos mirándote en la oscuridad.\n\r", ch );
//	}
	else if ( room_is_dark( ch->in_room )
	&&        IS_AFFECTED(ch, AFF_INFRARED ) )
	{
	    set_char_color( AT_BLOOD, ch );
	    send_to_char( "La forma roja de un ser vivo está aquí.\n\r", ch );
	}
    }

    return;
}

void show_ships_to_char( SHIP_DATA *ship, CHAR_DATA *ch )
{
    SHIP_DATA *rship;
    SHIP_DATA *nship=NULL;


    for ( rship = ship; rship; rship = nship )
    {
        ch_printf( ch , "&C%-35s     ", rship->name );
        if ( ( nship = rship->next_in_room ) !=NULL )
        {
            ch_printf( ch , "%-35s", nship->name );
            nship = nship->next_in_room;
        }
        ch_printf( ch, "\n\r&w");
    }

    return;
}



bool check_blind( CHAR_DATA *ch )
{
    if ( !IS_NPC(ch) && IS_SET(ch->act, PLR_HOLYLIGHT) )
	return TRUE;

    if ( IS_AFFECTED(ch, AFF_TRUESIGHT) )
      return TRUE;

    if ( IS_AFFECTED(ch, AFF_BLIND) )
    {
	send_to_char( "¡No puedes ver nada!\n\r", ch );
	return FALSE;
    }

    return TRUE;
}

/*
 * Returns classical DIKU door direction based on text in arg	-Thoric
 */
int get_door( const char *arg )
{
    int door;

	 if ( !str_cmp( arg, "n"  ) || !str_cmp( arg, "norte"	  ) ) door = 0;
    else if ( !str_cmp( arg, "e"  ) || !str_cmp( arg, "este"	  ) ) door = 1;
    else if ( !str_cmp( arg, "s"  ) || !str_cmp( arg, "sur"	  ) ) door = 2;
    else if ( !str_cmp( arg, "o"  ) || !str_cmp( arg, "oeste"	  ) ) door = 3;
    else if ( !str_cmp( arg, "u"  ) || !str_cmp( arg, "arriba"	  ) ) door = 4;
    else if ( !str_cmp( arg, "d"  ) || !str_cmp( arg, "abajo"	  ) ) door = 5;
    else if ( !str_cmp( arg, "ne" ) || !str_cmp( arg, "noreste" ) ) door = 6;
    else if ( !str_cmp( arg, "no" ) || !str_cmp( arg, "noroeste" ) ) door = 7;
    else if ( !str_cmp( arg, "se" ) || !str_cmp( arg, "sureste" ) ) door = 8;
    else if ( !str_cmp( arg, "so" ) || !str_cmp( arg, "suroeste" ) ) door = 9;
    else door = -1;
    return door;
}

void do_look
( CHAR_DATA *ch, const char *argument )
{
	char arg  [MAX_INPUT_LENGTH];
	char arg1 [MAX_INPUT_LENGTH];
	char arg2 [MAX_INPUT_LENGTH];
	char arg3 [MAX_INPUT_LENGTH];
	char *parg;
	EXIT_DATA *pexit;
	CHAR_DATA *victim;
	OBJ_DATA *obj;
	ROOM_INDEX_DATA *original;
	char *pdesc;
	sh_int door;
	int number, cnt;
	SHIP_DATA * ship;
	int i;

	if ( !ch->desc )
		return;

	if ( ch->position < POS_SLEEPING )
	{
		send_to_char( "¡No puedes ver nada salvo estrellas!\n\r", ch );
		return;
	}

	if ( ch->position == POS_SLEEPING )
	{
		send_to_char( "¡No puedes ver nada, estás durmiendo!\n\r", ch );
		return;
	}

	if ( !check_blind( ch ) )
		return;

	if ( !IS_NPC(ch)
	    &&   !IS_SET(ch->act, PLR_HOLYLIGHT)
	    &&   !IS_AFFECTED(ch, AFF_TRUESIGHT)
	    &&   room_is_dark( ch->in_room ) )
	{
		set_char_color( AT_DGREY, ch );
		send_to_char( "Está todo oscuro... \n\r", ch );
		show_char_to_char( ch->in_room->first_person, ch );
		return;
	}

	argument = one_argument( argument, arg1 );
	argument = one_argument( argument, arg2 );
	argument = one_argument( argument, arg3 );

	if ( arg1[0] == '\0' || !str_cmp( arg1, "auto" ) )
	{
		/* 'look' or 'look auto' */
		set_char_color( AT_RMNAME, ch);
		send_to_char( ch->in_room->name, ch);
		send_to_char(" ", ch);

		if ( ! ch->desc->original )
		{
			if ((get_trust(ch) >= LEVEL_IMMORTAL) && (IS_SET(ch->pcdata->flags, PCFLAG_ROOM)))
			{
				set_char_color(AT_BLUE, ch);       /* Added 10/17 by Kuran of */
				send_to_char("{", ch);                     /* SWReality */
				ch_printf(ch, "%d", ch->in_room->vnum);
				send_to_char("}", ch);
				set_char_color(AT_CYAN, ch);
				send_to_char("[", ch);
				send_to_char(long_flag_string(ch->in_room->room_flags, r_flags), ch);
				send_to_char("]", ch);
			}
		}

		send_to_char( "\n\r", ch );
		if (ch->pcdata && IS_SET(ch->pcdata->flags, PCFLAG_ACC_MOBS))
			show_char_to_char( ch->in_room->first_person,  ch );
		set_char_color( AT_RMDESC, ch );

		if ( arg1[0] == '\0'
		    || ( !IS_NPC(ch) && !IS_SET(ch->act, PLR_BRIEF) ) )
			send_to_char( ch->in_room->description, ch );

		if ( !IS_NPC(ch) && IS_SET(ch->act, PLR_AUTOEXIT) ) {
			if (IS_SET(ch->pcdata->flags, PCFLAG_ACC_SALIDAS))
				do_exits(ch, "auto");
			else
				do_exits( ch, "" );
		}
		if (ch->pcdata && IS_SET(ch->pcdata->flags, PCFLAG_ACC_NAVES)) {
			if (ch->in_room->first_ship)
				send_to_char("Hay naves aquí.\n\r", ch);
		} else
			show_ships_to_char( ch->in_room->first_ship, ch );
		show_list_to_char( ch->in_room->first_content, ch, FALSE, FALSE );
		if (!ch->pcdata || !IS_SET(ch->pcdata->flags, PCFLAG_ACC_MOBS))
			show_char_to_char( ch->in_room->first_person,  ch );
		if ( str_cmp( arg1, "auto" ) )
			if ((ship = ship_from_cockpit(ch->in_room->vnum))  != NULL )
		{
			set_char_color(  AT_WHITE, ch );
			ch_printf( ch , "\n\rA través de las ventanas de acero transparente puedes ver:\n\r" );

			if (ship->starsystem)
			{
				MISSILE_DATA *missile;
				RESOURCE_DATA *resource;
				SHIP_DATA *target;

				set_char_color(  AT_GREEN, ch );
				for (i=0; i<MAX_STARS; i++)
					if ( ship->starsystem->star[i] && str_cmp(ship->starsystem->star[i],"") )
						ch_printf(ch, "%s\n\r" ,
						          ship->starsystem->star[i]);
				for (i=0; i<MAX_PLANETS; i++)
					if ( ship->starsystem->planet[i] && str_cmp(ship->starsystem->planet[i],"") )
						ch_printf(ch, "%s\n\r" ,
						          ship->starsystem->planet[i] );
				for ( target = ship->starsystem->first_ship; target; target = target->next_in_starsystem )
				{
					if ( target != ship )
						ch_printf(ch, "%s\n\r",
						          target->name);
				}
				for ( missile = ship->starsystem->first_missile; missile; missile = missile->next_in_starsystem )
				{
					ch_printf(ch, "%s\n\r",
					          missile->missiletype == CONCUSSION_MISSILE ? "Un misil de concusion" :
					          ( missile->missiletype ==  PROTON_TORPEDO ? "Un torpedo" :
						           ( missile->missiletype ==  HEAVY_ROCKET ? "Un cohete pesado" : "Una bomba pesada" ) ) );
				}
				for (resource = ship->starsystem->first_resource; resource; resource = resource->next_in_starsystem) {
					if (resource->type != RESOURCE_CONTAINER || (fabs(ship->vx-resource->mx)<400 && fabs(ship->vy-resource->my)<400 &&
							fabs(ship->vz-resource->mz)<400))
						ch_printf(ch, "%s\n\r", capitalize(resource->short_desc));
				}
			}
			else if ( ship->location == ship->lastdoc )
			{
				ROOM_INDEX_DATA *to_room;

				if ( (to_room = get_room_index( ship->location ) ) != NULL )
				{
					ch_printf( ch, "\n\r" );
					original = ch->in_room;
					char_from_room( ch );
					char_to_room( ch, to_room );
					do_glance( ch, "" );
					char_from_room( ch );
					char_to_room( ch, original );
				}
			}


		}

		return;
	}

	if ( !str_cmp( arg2, "de" ) )	/* samsa */
		parg = arg3;
	else
		parg = arg2;

	if ( !str_cmp( arg1, "debajo" ) )
	{
		int count;

		/* 'look under' */
		if ( parg[0] == '\0' )
		{
			send_to_char( "¿Debajo de qué quieres mirar?\n\r", ch );
			return;
		}

		if ( ( obj = get_obj_here( ch, parg ) ) == NULL )
		{
			send_to_char( "No ves nada ahí.\n\r", ch );
			return;
		}
		if ( ch->carry_weight + obj->weight > can_carry_w( ch ) )
		{
			send_to_char( "Es demasiado pesado para mirar debajo.\n\r", ch );
			return;
		}
		count = obj->count;
		obj->count = 1;
		act( AT_PLAIN, "Levantas $p y miras debajo:", ch, obj, NULL, TO_CHAR );
		act( AT_PLAIN, "$n levanta $p mira debajo:", ch, obj, NULL, TO_ROOM );
		obj->count = count;
		if ( IS_OBJ_STAT( obj, ITEM_COVERING ) )
			show_list_to_char( obj->first_content, ch, TRUE, TRUE );
		else
			send_to_char( "Nada.\n\r", ch );
		if( EXA_prog_trigger ) oprog_examine_trigger( ch, obj );
		return;
	}

	if ( !str_cmp( arg1, "en" ) || !str_cmp( arg1, "dentro" ) )
	{
		int count;

		/* 'look in' */
		if ( parg[0] == '\0' )
		{
			send_to_char( "¿Dentro de qué quieres mirar?\n\r", ch );
			return;
		}

		if ( ( obj = get_obj_here( ch, parg ) ) == NULL )
		{
			send_to_char( "No ves nada ahí.\n\r", ch );
			return;
		}

		switch ( obj->item_type )
		{
			default:
				send_to_char( "Eso no es un contenedor.\n\r", ch );
				break;

			case ITEM_DRINK_CON:
				if ( obj->value[1] <= 0 )
			{
				send_to_char( "Está vacío.\n\r", ch );
				if( EXA_prog_trigger ) oprog_examine_trigger( ch, obj );
				break;
			}
				LIQ_TABLE *liq = get_liq_vnum( obj->value[2] );
				ch_printf( ch, "Está %s lleno de un líquido %s.\n\r", obj->value[1] < obj->value[0] / 4
				          ? "poco" : obj->value[1] < 3 * obj->value[0] / 4? "medio" : "muy", liq->color);

				if( EXA_prog_trigger ) oprog_examine_trigger( ch, obj );
				break;

			case ITEM_PORTAL:
				for ( pexit = ch->in_room->first_exit; pexit; pexit = pexit->next )
			{
				if ( pexit->vdir == DIR_PORTAL
				    &&   IS_SET(pexit->exit_info, EX_PORTAL) )
				{
					if ( room_is_private( ch, pexit->to_room )
					    &&   get_trust(ch) < sysdata.level_override_private )
					{
						set_char_color( AT_WHITE, ch );
						send_to_char( "¡Esa habitación es privada!\n\r", ch );
						return;
					}
					original = ch->in_room;
					char_from_room( ch );
					char_to_room( ch, pexit->to_room );
					do_look( ch, "auto" );
					char_from_room( ch );
					char_to_room( ch, original );
					return;
				}
			}
				send_to_char( "Ves una espiral de caos...\n\r", ch );
				break;
			case ITEM_CONTAINER:
			case ITEM_CORPSE_NPC:
			case ITEM_CORPSE_PC:
			case ITEM_DROID_CORPSE:
				if ( IS_SET(obj->value[1], CONT_CLOSED) )
			{
				send_to_char( "Está cerrado.\n\r", ch );
				break;
			}

				count = obj->count;
				obj->count = 1;
				act( AT_PLAIN, "$p contiene:", ch, obj, NULL, TO_CHAR );
				obj->count = count;
				show_list_to_char( obj->first_content, ch, TRUE, TRUE );
				if( EXA_prog_trigger ) oprog_examine_trigger( ch, obj );
				break;
		}
		return;
	}

	if ( (pdesc=get_extra_descr(arg1, ch->in_room->first_extradesc)) != NULL )
	{
		send_to_char( pdesc, ch );
		return;
	}

	door = get_door( arg1 );
	if ( ( pexit = find_door( ch, arg1, TRUE ) ) != NULL )
	{
		if ( pexit->keyword )
		{
			if ( IS_SET(pexit->exit_info, EX_CLOSED)
			    &&  !IS_SET(pexit->exit_info, EX_WINDOW) )
			{
				if ( IS_SET(pexit->exit_info, EX_SECRET)
				    &&   door != -1 )
					send_to_char( "Nada especial ahí.\n\r", ch );
				else
					act( AT_PLAIN, "$d está cerrada.", ch, NULL, pexit->keyword, TO_CHAR );
				return;
			}
			if ( IS_SET( pexit->exit_info, EX_BASHED ) )
				act(AT_RED, "¡$d ha sido derrumbada!",ch, NULL, pexit->keyword, TO_CHAR);
		}

		if ( pexit->description && pexit->description[0] != '\0' )
			send_to_char( pexit->description, ch );
		else
			send_to_char( "Nada especial ahí.\n\r", ch );

		/*
		 * Ability to look into the next room			-Thoric
		 */
		if ( pexit->to_room
		    && ( IS_AFFECTED( ch, AFF_SCRYING )
		        ||   IS_SET( pexit->exit_info, EX_xLOOK )
		        ||   get_trust(ch) >= LEVEL_IMMORTAL ) )
		{
			if ( !IS_SET( pexit->exit_info, EX_xLOOK )
			    &&    get_trust( ch ) < LEVEL_IMMORTAL )
			{
				set_char_color( AT_MAGIC, ch );
				send_to_char( "Intentas percibir (scry)...\n\r", ch );
				/* Change by Narn, Sept 96 to allow characters who don't have the
				 scry spell to benefit from objects that are affected by scry.
				 */
				if (!IS_NPC(ch) )
				{
					int percent = ch->pcdata->learned[ skill_lookup("scry") ];
					if ( !percent )
						percent = 99;

					if(  number_percent( ) > percent )
					{
						send_to_char( "Has fallado.\n\r", ch );
						return;
					}
				}
			}
			if ( room_is_private( ch, pexit->to_room )
			    &&   get_trust(ch) < sysdata.level_override_private )
			{
				set_char_color( AT_WHITE, ch );
				send_to_char( "¡Esa habitación es privada!\n\r", ch );
				return;
			}
			original = ch->in_room;
			if ( pexit->distance > 1 )
			{
				ROOM_INDEX_DATA * to_room;
				if ( (to_room=generate_exit(ch->in_room, &pexit)) != NULL )
				{
					char_from_room( ch );
					char_to_room( ch, to_room );
				}
				else
				{
					char_from_room( ch );
					char_to_room( ch, pexit->to_room );
				}
			}
			else
			{
				char_from_room( ch );
				char_to_room( ch, pexit->to_room );
			}
			do_look( ch, "auto" );
			char_from_room( ch );
			char_to_room( ch, original );
		}
		return;
	}
	else
		if ( door != -1 )
	{
		send_to_char( "Nada especial ahí.\n\r", ch );
		return;
	}

	if ( ( victim = get_char_room( ch, arg1 ) ) != NULL )
	{
		show_char_to_char_1( victim, ch );
		return;
	}


	/* finally fixed the annoying look 2.obj desc bug	-Thoric */
	number = number_argument( arg1, arg );
	for ( cnt = 0, obj = ch->last_carrying; obj; obj = obj->prev_content )
	{
		if ( can_see_obj( ch, obj ) )
		{
			if ( (pdesc=get_extra_descr(arg, obj->first_extradesc)) != NULL )
			{
				if ( (cnt += obj->count) < number )
					continue;
				send_to_char( pdesc, ch );
				if( EXA_prog_trigger ) oprog_examine_trigger( ch, obj );
				return;
			}

			if ( (pdesc=get_extra_descr(arg, obj->pIndexData->first_extradesc)) != NULL )
			{
				if ( (cnt += obj->count) < number )
					continue;
				send_to_char( pdesc, ch );
				if( EXA_prog_trigger ) oprog_examine_trigger( ch, obj );
				return;
			}

			if ( nifty_is_name_prefix( arg, obj->name ) )
			{
				if ( (cnt += obj->count) < number )
					continue;
				pdesc = get_extra_descr( obj->name, obj->pIndexData->first_extradesc );
				if ( !pdesc )
					pdesc = get_extra_descr( obj->name, obj->first_extradesc );
				if ( !pdesc )
					send_to_char( "No ves nada especial.\r\n", ch );
				else
					send_to_char( pdesc, ch );
				if( EXA_prog_trigger ) oprog_examine_trigger( ch, obj );
				return;
			}
		}
	}

	for ( obj = ch->in_room->last_content; obj; obj = obj->prev_content )
	{
		if ( can_see_obj( ch, obj ) )
		{
			if ( (pdesc=get_extra_descr(arg, obj->first_extradesc)) != NULL )
			{
				if ( (cnt += obj->count) < number )
					continue;
				send_to_char( pdesc, ch );
				if( EXA_prog_trigger ) oprog_examine_trigger( ch, obj );
				return;
			}

			if ( (pdesc=get_extra_descr(arg, obj->pIndexData->first_extradesc)) != NULL )
			{
				if ( (cnt += obj->count) < number )
					continue;
				send_to_char( pdesc, ch );
				if( EXA_prog_trigger ) oprog_examine_trigger( ch, obj );
				return;
			}
			if ( nifty_is_name_prefix( arg, obj->name ) )
			{
				if ( (cnt += obj->count) < number )
					continue;
				pdesc = get_extra_descr( obj->name, obj->pIndexData->first_extradesc );
				if ( !pdesc )
					pdesc = get_extra_descr( obj->name, obj->first_extradesc );
				if ( !pdesc )
					send_to_char( "No ves nada especial.\r\n", ch );
				else
					send_to_char( pdesc, ch );
				if( EXA_prog_trigger ) oprog_examine_trigger( ch, obj );
				return;
			}
		}
	}

	if ( ( ship = ship_in_room( ch->in_room , arg1 ) ) != NULL ) {
		if (ship->description && ship->description[0] != '\0')
			send_to_char(ship->description, ch);
		else
			send_to_char("No notas nada particular en esta nave.\n\r", ch);
		return;
	}
	if (((ship = ship_from_cockpit(ch->in_room->vnum)) != NULL) && ship->starsystem) {
		if (nifty_is_name_prefix (arg1, ship->starsystem->name)) {
			if (ship->starsystem->desc && ship->starsystem->desc[0]!='\0')
				send_to_char(ship->starsystem->desc, ch);
			else
				send_to_char("No notas nada particular en este sistema estelar.\n\r", ch);
			return;
		}
		for (i=0; i<MAX_PLANETS; i++) {
			if (nifty_is_name_prefix (arg1, ship->starsystem->planet[i])) {
				if (ship->starsystem->pdesc[i] && ship->starsystem->pdesc[i][0]!='\0')
					send_to_char(ship->starsystem->pdesc[i], ch);
				else
					send_to_char("No notas nada particular en este planeta.\n\r", ch);
				return;
			}
		}
		if ((ship = get_ship_here(arg1, ship->starsystem)) != NULL) {
			if (ship->description && ship->description[0] != '\0')
				send_to_char(ship->description, ch);
			else
				send_to_char("No notas nada particular en esta nave.\n\r", ch);
			return;
		}
	}


	send_to_char( "No ves eso ahí.\n\r", ch );
	return;
}

void show_condition( CHAR_DATA *ch, CHAR_DATA *victim )
{
    char buf[MAX_STRING_LENGTH];
    int percent;

    if ( victim->max_hit > 0 )
        percent = ( 100 * victim->hit ) / victim->max_hit;
    else
        percent = -1;


    strcpy( buf, PERS(victim, ch) );

    if ( IS_NPC ( victim ) && IS_SET( victim->act , ACT_DROID ) )
    {

         if ( percent >= 100 ) strcat( buf, " está en perfectas condiciones.\n\r"  );
    else if ( percent >=  90 ) strcat( buf, " está ligeramente arañado.\n\r" );
    else if ( percent >=  80 ) strcat( buf, " tiene alguna abolladura.\n\r"     );
    else if ( percent >=  70 ) strcat( buf, " está algo deformado.\n\r"         );
    else if ( percent >=  60 ) strcat( buf, " tiene algun agujero en su soldadura.\n\r"    );
    else if ( percent >=  50 ) strcat( buf, " tiene varias piezas rotas.\n\r" );
    else if ( percent >=  40 ) strcat( buf, " tiene varios circuitos al descubierto.\n\r"    );
    else if ( percent >=  30 ) strcat( buf, " está derramando aceite.\n\r"   );
    else if ( percent >=  20 ) strcat( buf, " está echando humo.\n\r"       );
    else if ( percent >=  10 ) strcat( buf, " está prácticamente roto.\n\r"        );
    else                       strcat( buf, " está a punto de EXPLOTAR.\n\r"              );

    }
    else
    {

         if ( percent >= 100 ) strcat( buf, " está en perfecto estado de salud.\n\r"  );
    else if ( percent >=  90 ) strcat( buf, " tiene unos pocos arañazos.\n\r" );
    else if ( percent >=  80 ) strcat( buf, " tiene bastantes arañazos.\n\r"     );
    else if ( percent >=  70 ) strcat( buf, " tiene algunos cortes.\n\r"         );
    else if ( percent >=  60 ) strcat( buf, " tiene bastantes heridas.\n\r"    );
    else if ( percent >=  50 ) strcat( buf, " tiene muchas heridas profundas.\n\r" );
    else if ( percent >=  40 ) strcat( buf, " está sangrando abundantemente.\n\r"    );
    else if ( percent >=  30 ) strcat( buf, " está cubierto de sangre.\n\r"   );
    else if ( percent >=  20 ) strcat( buf, " se está desangrando.\n\r"       );
    else if ( percent >=  10 ) strcat( buf, " está casi muerto.\n\r"        );
    else                       strcat( buf, " se está MURIENDO.\n\r"              );

    }
    buf[0] = toupper(buf[0]);
    send_to_char( buf, ch );
    return;
}

/* A much simpler version of look, this function will show you only
the condition of a mob or pc, or if used without an argument, the
same you would see if you enter the room and have config +brief.
-- Narn, winter '96
*/
void do_glance( CHAR_DATA *ch, const char *argument )
{
  char arg1 [MAX_INPUT_LENGTH];
  CHAR_DATA *victim;
  int save_act;

  if ( !ch->desc )
    return;

  if ( ch->position < POS_SLEEPING )
  {
    send_to_char( "¡No puedes ver nada salvo las estrellas!\n\r", ch );
    return;
  }

  if ( ch->position == POS_SLEEPING )
  {
    send_to_char( "¡No puedes ver nada, estás durmiendo!\n\r", ch );
    return;
  }

  if ( !check_blind( ch ) )
    return;

  argument = one_argument( argument, arg1 );

  if ( arg1[0] == '\0' )
  {
    save_act = ch->act;
    SET_BIT( ch->act, PLR_BRIEF );
    do_look( ch, "auto" );
    ch->act = save_act;
    return;
  }

  if ( ( victim = get_char_room( ch, arg1 ) ) == NULL )
  {
    send_to_char( "No están aquí.", ch );
    return;
  }
  else
  {
    if ( can_see( victim, ch ) )
    {
      act( AT_ACTION, "$n te echa un vistazo.", ch, NULL, victim, TO_VICT    );
      act( AT_ACTION, "$n echa un vistazo a $N.",  ch, NULL, victim, TO_NOTVICT );
    }

    show_condition( ch, victim );
    return;
  }

  return;
}


void do_examine( CHAR_DATA *ch, const char *argument )
{
    char buf[MAX_STRING_LENGTH];
    char arg[MAX_INPUT_LENGTH];
    OBJ_DATA *obj;
    BOARD_DATA *board;
    sh_int dam;

    if ( !argument )
    {
	bug( "do_examine: null argument.", 0);
	return;
    }

    if ( !ch )
    {
	bug( "do_examine: null ch.", 0);
	return;
    }

    one_argument( argument, arg );

    if ( arg[0] == '\0' )
    {
	send_to_char( "¿Examinar qué?\n\r", ch );
	return;
    }

   EXA_prog_trigger = FALSE;
   do_look( ch, arg );
   EXA_prog_trigger = TRUE;

    /*
     * Support for looking at boards, checking equipment conditions,
     * and support for trigger positions by Thoric
     */
    if ( ( obj = get_obj_here( ch, arg ) ) != NULL )
    {
	if ( (board = get_board( obj )) != NULL )
	{
	   if ( board->num_posts )
	     ch_printf( ch, "Hay como unos %d mensajes aquí.  Escribe 'nota lista' para listarlos.\n\r", board->num_posts );
	   else
	     send_to_char( "No hay ningun mensaje publicada aquí.\n\r", ch );
	}

	switch ( obj->item_type )
	{
	default:
	    break;

	case ITEM_ARMORMETAL:
	    if ( obj->value[1] == 0 )
	      obj->value[1] = obj->value[0];
	    if ( obj->value[1] == 0 )
	      obj->value[1] = 1;
	    dam = (sh_int) ((obj->value[0] * 10) / obj->value[1]);
	    strcpy( buf, "Miras con  detenimiento y notas que ");
	    if (dam >= 10) strcat( buf, "está en perfectas condiciones.");
       else if (dam ==  9) strcat( buf, "está en muy buen estado.");
       else if (dam ==  8) strcat( buf, "está en buen estado.");
       else if (dam ==  7) strcat( buf, "se ha usado un poco.");
       else if (dam ==  6) strcat( buf, "se ha usado bastante.");
       else if (dam ==  5) strcat( buf, "necesitaráa una reparación.");
       else if (dam ==  4) strcat( buf, "necesita repararse pronto.");
       else if (dam ==  3) strcat( buf, "necesita una reparación con urgencia.");
       else if (dam ==  2) strcat( buf, "apenas está de una pieza.");
       else if (dam ==  1) strcat( buf, "está prácticamente inservible.");
       else if (dam <=  0) strcat( buf, "está roto.");
	    strcat( buf, "\n\r" );
	    send_to_char( buf, ch );
	    break;

	case ITEM_ARMORTELA:
	    if ( obj->value[1] == 0 )
	      obj->value[1] = obj->value[0];
	    if ( obj->value[1] == 0 )
	      obj->value[1] = 1;
	    dam = (sh_int) ((obj->value[0] * 10) / obj->value[1]);
	    strcpy( buf, "Miras con  detenimiento y notas que ");
	    if (dam >= 10) strcat( buf, "está en perfectas condiciones.");
       else if (dam ==  9) strcat( buf, "está en muy buen estado.");
       else if (dam ==  8) strcat( buf, "está en buen estado.");
       else if (dam ==  7) strcat( buf, "se ha usado un poco.");
       else if (dam ==  6) strcat( buf, "se ha usado bastante.");
       else if (dam ==  5) strcat( buf, "necesitaría una reparación.");
       else if (dam ==  4) strcat( buf, "necesita repararse pronto.");
       else if (dam ==  3) strcat( buf, "necesita una reparación con urgencia.");
       else if (dam ==  2) strcat( buf, "apenas está de una pieza.");
       else if (dam ==  1) strcat( buf, "está prácticamente inservible.");
       else if (dam <=  0) strcat( buf, "está roto.");
	    strcat( buf, "\n\r" );
	    send_to_char( buf, ch );
	    break;

	case ITEM_ARMOROTRO:
	    if ( obj->value[1] == 0 )
	      obj->value[1] = obj->value[0];
	    if ( obj->value[1] == 0 )
	      obj->value[1] = 1;
	    dam = (sh_int) ((obj->value[0] * 10) / obj->value[1]);
	    strcpy( buf, "Miras con  detenimiento y notas que ");
	    if (dam >= 10) strcat( buf, "está en perfectas condiciones.");
       else if (dam ==  9) strcat( buf, "está en muy buen estado.");
       else if (dam ==  8) strcat( buf, "está en buen estado.");
       else if (dam ==  7) strcat( buf, "se ha usado un poco.");
       else if (dam ==  6) strcat( buf, "se ha usado bastante.");
       else if (dam ==  5) strcat( buf, "necesitaría una reparación.");
       else if (dam ==  4) strcat( buf, "necesita repararse pronto.");
       else if (dam ==  3) strcat( buf, "necesita una reparación con urgencia.");
       else if (dam ==  2) strcat( buf, "apenas está de una pieza.");
       else if (dam ==  1) strcat( buf, "está prácticamente inservible.");
       else if (dam <=  0) strcat( buf, "está roto.");
	    strcat( buf, "\n\r" );
	    send_to_char( buf, ch );
	    break;

	case ITEM_WEAPON:
			dam = INIT_WEAPON_CONDITION - obj->value[0];
			strcpy( buf, "Lo miras con detenimiento y ves que ");
			if (dam ==  0) strcat( buf, "está en perfectas condiciones.");
			else if (dam ==  1) strcat( buf, "está en excelentes condiciones.");
			else if (dam ==  2) strcat( buf, "está en muy buen estado.");
			else if (dam ==  3) strcat( buf, "está en buen estado.");
			else if (dam ==  4) strcat( buf, "se ha usado un poco.");
			else if (dam ==  5) strcat( buf, "se ha usado bastante.");
			else if (dam ==  6) strcat( buf, "necesitaría una reparación.");
			else if (dam ==  7) strcat( buf, "necesita repararse pronto.");
			else if (dam ==  8) strcat( buf, "necesita una reparación con urgencia.");
			else if (dam ==  9) strcat( buf, "apenas está de una pieza.");
			else if (dam == 10) strcat( buf, "está prácticamente inservible.");
			else if (dam == 11) strcat( buf, "está casi roto.");
			else if (dam == 12) strcat( buf, "está roto.");
			strcat( buf, "\n\r" );
			send_to_char( buf, ch );
			if (IS_ADJUSTABLE_WEAPON(obj))
		{
			if (obj->blaster_setting == BLASTER_FULL)
				ch_printf( ch, "Está en modo MÁXIMO de energía.\n\r");
			else if (obj->blaster_setting == BLASTER_HIGH)
				ch_printf( ch, "Está en modo ALTO de energia.\n\r");
			else if (obj->blaster_setting == BLASTER_NORMAL)
				ch_printf( ch, "Está en modo NORMAL de energia.\n\r");
			else if (obj->blaster_setting == BLASTER_HALF)
				ch_printf( ch, "Está en modo MEDIO de energia.\n\r");
			else if (obj->blaster_setting == BLASTER_LOW)
				ch_printf( ch, "Está en modo BAJO de energia.\n\r");
			else if (obj->blaster_setting == BLASTER_STUN)
				ch_printf( ch, "Está en modo ATURDIR.\n\r");
			ch_printf( ch, "Tiene aún entre %d y %d disparos.\n\r", obj->value[4]/5 , obj->value[4] );
		} else if (IS_FIRE_WEAPON(obj)) {
			ch_printf( ch, "Tiene aún %d disparos.\n\r", obj->value[4] );
		}
			else if (     ( obj->value[3] == WEAPON_IMPACTO ||
						   obj->value[3] == WEAPON_VIBRO_BLADE ||
			               obj->value[3] == WEAPON_VIBRO_AXE ||
						   obj->value[3] == WEAPON_FORCE_PIKE ||
			               obj->value[3] == WEAPON_CUCHILLO_LASER ) )
		{
			ch_printf( ch, "Aún tiene %d/%d unidades de carga.\n\r", obj->value[4] , obj->value[5] );
		}
	    break;

	case ITEM_FOOD:
	    if ( obj->timer > 0 && obj->value[1] > 0 )
	      dam = (obj->timer * 10) / obj->value[1];
	    else
	      dam = 10;
	    strcpy( buf, "Cuando lo examinas cuidadosamente notas que " );
	    if (dam >= 10) strcat( buf, "está fresco.");
       else if (dam ==  9) strcat( buf, "está casi fresco.");
       else if (dam ==  8) strcat( buf, "tiene buen color.");
       else if (dam ==  7) strcat( buf, "tiene un buen aspecto.");
       else if (dam ==  6) strcat( buf, "está bien.");
       else if (dam ==  5) strcat( buf, "está un poco rancio.");
       else if (dam ==  4) strcat( buf, "está bastante rancio.");
       else if (dam ==  3) strcat( buf, "huele un poco mal.");
       else if (dam ==  2) strcat( buf, "huele fatal.");
       else if (dam ==  1) strcat( buf, "al olerlo dan ganas de vomitar.");
       else if (dam <=  0) strcat( buf, "está lleno de gusanos.");
	    strcat( buf, "\n\r" );
	    send_to_char( buf, ch );
	    break;

	case ITEM_SWITCH:
	case ITEM_LEVER:
	case ITEM_PULLCHAIN:
	    if ( IS_SET( obj->value[0], TRIG_UP ) )
		send_to_char( "Adviertes que está en la posición de arriba.\n\r", ch );
	    else
		send_to_char( "Adviertes que está en la posición de abajo.\n\r", ch );
	    break;
	case ITEM_BUTTON:
	    if ( IS_SET( obj->value[0], TRIG_UP ) )
		send_to_char( "Ves que ha sido presionado.\n\r", ch );
	    else
		send_to_char( "Ves que no ha sido presionado.\n\r", ch );
	    break;

        case ITEM_CORPSE_PC:
	case ITEM_CORPSE_NPC:
            {
		sh_int timerfrac = obj->timer;
		if ( obj->item_type == ITEM_CORPSE_PC )
		timerfrac = (int)obj->timer / 8 + 1;

		switch (timerfrac)
		{
		    default:
			send_to_char( "Este cuerpo ha sido asesinado recientemente.\n\r", ch );
			break;
		    case 4:
			send_to_char( "Este cuerpo ha sido asesinado hace algún tiempo.\n\r", ch );
			break;
		    case 3:
			send_to_char( "Un hedor se desprende de este cuerpo cubierto de moscas.\n\r", ch );
			break;
		    case 2:
			send_to_char( "Una masa de gusanos devora un cuerpo en descomposición.\n\r", ch );
			break;
		    case 1:
		    case 0:
			send_to_char( "Queda poco más que los huesos en este cuerpo.\n\r", ch );
			break;
		}
            }
	    if ( IS_OBJ_STAT( obj, ITEM_COVERING ) )
	      break;
	    send_to_char( "Cuando miras dentro, puedes ver:\n\r", ch );
		EXA_prog_trigger = FALSE;
		sprintf( buf, "en %s",arg );
		do_look( ch, buf );
		EXA_prog_trigger = TRUE;
	    break;

	case ITEM_DROID_CORPSE:
            {
		sh_int timerfrac = obj->timer;

		switch (timerfrac)
		{
		    default:
			send_to_char( "Estos restos están todavía humeando.\n\r", ch );
			break;
		    case 4:
			send_to_char( "Las piezas de este androide están inservibles.\n\r", ch );
			break;
		    case 3:
			send_to_char( "Los componentes de un androide roto se están oxidando.\n\r", ch );
			break;
		    case 2:
			send_to_char( "Las piezas están completamente cubiertas de óxido.\n\r", ch );
			break;
		    case 1:
		    case 0:
			send_to_char( "Todos esos restos son una pila de chatarra.\n\r", ch );
			break;
		}
            }

	case ITEM_CONTAINER:
	    if ( IS_OBJ_STAT( obj, ITEM_COVERING ) )
	        break;

	case ITEM_DRINK_CON:
	    send_to_char( "Cuando miras dentro, puedes ver:\n\r", ch );
	EXA_prog_trigger = FALSE;
	sprintf( buf, "dentro de %s", arg );
	do_look( ch, buf );
	EXA_prog_trigger = TRUE;
		break;
	case ITEM_LIGHT:
		if (obj->value[2] <= 0)
			send_to_char("Está agotado y ya no emite ninguna luz.\n\r", ch);
		else
			ch_printf(ch, "Le quedan %d horas de luz.\n\r", obj->value[2]);
		break;
	}
	if ( IS_OBJ_STAT( obj, ITEM_COVERING ) )
	{
	    sprintf( buf, "debajo de %s noprog", arg );
	    do_look( ch, buf );
	}
	oprog_examine_trigger( ch, obj );
	if( char_died(ch) || obj_extracted(obj) )
	  return;

	check_for_trap( ch, obj, TRAP_EXAMINE );
	}
    return;
}


void do_exits( CHAR_DATA *ch, const char *argument )
{
	char buf[MAX_STRING_LENGTH];
	EXIT_DATA *pexit;
	bool found;
	bool fAuto;

	set_char_color( AT_EXITS, ch );
	buf[0] = '\0';
	fAuto  = !str_cmp( argument, "auto" );

	if ( !check_blind( ch ) )
		return;

	strcpy( buf, fAuto ? "Salidas obvias:" : "Salidas obvias:\n\r" );

	found = FALSE;
	for ( pexit = ch->in_room->first_exit; pexit; pexit = pexit->next ) {
		if ( pexit->to_room && !IS_SET(pexit->exit_info, EX_HIDDEN) ) {
			found = TRUE;
			if ( !fAuto ) {
				if ( IS_SET(pexit->exit_info, EX_CLOSED) ) {
					sprintf( buf + strlen(buf), "%-5s - (cerrado)\n\r", capitalize( dir_name[pexit->vdir] ) );
				} else if ( IS_SET(pexit->exit_info, EX_WINDOW) ) {
					sprintf( buf + strlen(buf), "%-5s - (ventana)\n\r", capitalize( dir_name[pexit->vdir] ) );
				} else if ( IS_SET(pexit->exit_info, EX_xAUTO) ) {
					sprintf( buf + strlen(buf), "%-5s - %s\n\r", capitalize( pexit->keyword ), room_is_dark( pexit->to_room )?  "Demasiado oscuro..."
					        : pexit->to_room->name );
				} else
					sprintf( buf + strlen(buf), "%-5s - %s\n\r", capitalize( dir_name[pexit->vdir] ), room_is_dark( pexit->to_room )?  "Demasiado oscuro..."
					        : pexit->to_room->name );
			} else {
				sprintf( buf + strlen(buf), " %s", ( dir_name[pexit->vdir] ) );
			}
		}
	}

	if ( !found )
		strcat( buf, fAuto ? " ninguna.\n\r" : "Ninguna.\n\r" );
	else
		if ( fAuto )
			strcat( buf, ".\n\r" );
	send_to_char( buf, ch );
	return;
}

char *	const	day_name	[] =
{
	"0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15"
};

char *	const	month_name	[] =
{
    "Primero", "Segundo", "Tercero", "Cuarto",
    "Quinto", "Sexto", "Séptimo", "Octavo", "Noveno",
    "Décimo", "Décimo Primero", "Décimo Segundo", "Décimo Tercero", "Décimo Cuarto",
    "Décimo Quinto", "Décimo Sexto"
};

void do_time( CHAR_DATA *ch, const char *argument )
{
	extern char str_boot_time[];
	extern char reboot_time[];
	int day;

	day     = time_info.day + 1;

	set_char_color( AT_YELLOW, ch );
	ch_printf( ch,
			  "Son las %d del día %d del mes %s (Fecha Mercantil Estándar).\n\r"
			  "El mud arrancó a las:    %s\r"
			  "Hora del sistema: %s\r"
			  "El próximo reboot será a las:   %s\r", time_info.hour, day,
			  month_name[time_info.month],
			  str_boot_time,
			  (char *) ctime( &current_time ),
			  reboot_time
			  );

	return;
}


/*
void do_weather( CHAR_DATA *ch, char *argument )
{
    static char * const sky_look[4] =
    {
	"despejado",
	"nublado",
	"lluvioso",
	"cruzado por relámpagos"
    };

    if ( !IS_OUTSIDE(ch) )
    {
	send_to_char( "No puedes ver el cielo desde aquí.\n\r", ch );
	return;
    }

    set_char_color( AT_BLUE, ch );
    ch_printf( ch, "El cielo está %s y %s.\n\r",
	sky_look[weather_info.sky],
	weather_info.change >= 0
	? "sopla una suave brisa"
	: "sopla un frío viento"
	);
    return;
}
*/

/*
 * Produce a description of the weather based on area weather using
 * the following sentence format:
 *		<combo-phrase> and <single-phrase>.
 * Where the combo-phrase describes either the precipitation and
 * temperature or the wind and temperature. The single-phrase
 * describes either the wind or precipitation depending upon the
 * combo-phrase.
 * Last Modified: July 31, 1997
 * Fireblade - Under Construction
 */
void do_weather(CHAR_DATA *ch, const char *argument)
{
	char *combo, *single;
	char buf[MAX_INPUT_LENGTH];
	int temp, precip, wind;

	if ( !IS_OUTSIDE(ch) )
	{
	    ch_printf(ch, "No puedes ver el cielo desde aquí.\n\r");
	    return;
	}

	temp = (ch->in_room->area->weather->temp + 3*weath_unit - 1)/
		weath_unit;
	precip = (ch->in_room->area->weather->precip + 3*weath_unit - 1)/
		weath_unit;
	wind = (ch->in_room->area->weather->wind + 3*weath_unit - 1)/
		weath_unit;

	if ( precip >= 3 )
	{
	    combo = preciptemp_msg[precip][temp];
	    single = wind_msg[wind];
	}
	else
	{
	    combo = windtemp_msg[wind][temp];
	    single = precip_msg[precip];
	}

	sprintf(buf, "%s y %s.\n\r", combo, single);

	set_char_color(AT_BLUE, ch);

	ch_printf(ch, buf);
}

/*
 * Moved into a separate function so it can be used for other things
 * ie: online help editing				-Thoric
 */
HELP_DATA *get_help( CHAR_DATA *ch, const char *argument )
{
    char argall[MAX_INPUT_LENGTH];
    char argone[MAX_INPUT_LENGTH];
    char argnew[MAX_INPUT_LENGTH];
    HELP_DATA *pHelp;
    int lev;

    if ( argument[0] == '\0' )
	argument = "sumario";

    if ( isdigit(argument[0]) )
    {
	lev = number_argument( argument, argnew );
	argument = argnew;
    }
    else
	lev = -2;
    /*
     * Tricky argument handling so 'help a b' doesn't match a.
     */
    argall[0] = '\0';
    while ( argument[0] != '\0' )
    {
	argument = one_argument( argument, argone );
	if ( argall[0] != '\0' )
	    strcat( argall, " " );
	strcat( argall, argone );
    }

    for ( pHelp = first_help; pHelp; pHelp = pHelp->next )
    {
	if ( pHelp->level > get_trust( ch ) )
	    continue;
	if ( lev != -2 && pHelp->level != lev )
	    continue;

	if ( is_name( argall, pHelp->keyword ) )
	    return pHelp;
    }

    return NULL;
}


/*
 * Now this is cleaner
 */
void do_help( CHAR_DATA *ch, const char *argument )
{
    HELP_DATA *pHelp;

	if (argument == NULL || argument[0] == '\0') {
		do_help(ch, "ayuda");
		return;
	}

    if ( (pHelp = get_help( ch, argument )) == NULL )
    {
	send_to_char( "No existe ayuda para la palabra solicitada.\n\r", ch );
		bug("do_help: ayuda inexistente: %s", argument);
	return;
    }

    if ( pHelp->level >= 0 && str_cmp( argument, "imotd" ) )
    {
	send_to_pager( pHelp->keyword, ch );
	send_to_pager( "\n\r", ch );
    }

    if ( !IS_NPC(ch) && IS_SET( ch->act , PLR_SOUND ) )
        send_to_pager( "!!SOUND(help)", ch );

    /*
     * Strip leading '.' to allow initial blanks.
     */
    if ( pHelp->text[0] == '.' )
	send_to_pager_color( pHelp->text+1, ch );
    else
	send_to_pager_color( pHelp->text  , ch );
    return;
}

/*
 * Help editor							-Thoric
 */
void do_hedit( CHAR_DATA *ch, const char *argument )
{
    HELP_DATA *pHelp;

    if ( !ch->desc )
    {
	send_to_char( "No tienes descriptor.\n\r", ch );
	return;
    }

    switch( ch->substate )
    {
	default:
	  break;
	case SUB_HELP_EDIT:
	  if ( (pHelp = ch->dest_buf) == NULL )
	  {
		bug( "hedit: sub_help_edit: NULL ch->dest_buf", 0 );
		stop_editing( ch );
		return;
	  }
	  STRFREE( pHelp->text );
	  pHelp->text = copy_buffer( ch );
	  stop_editing( ch );
	  return;
    }
    if ( (pHelp = get_help( ch, argument )) == NULL )	/* new help */
    {
	char argnew[MAX_INPUT_LENGTH];
	int lev;

	if ( isdigit(argument[0]) )
	{
	    lev = number_argument( argument, argnew );
	    argument = argnew;
	}
	else
	    lev = get_trust(ch);
	CREATE( pHelp, HELP_DATA, 1 );
	pHelp->keyword = STRALLOC( strupper(argument) );
	pHelp->text    = STRALLOC( "" );
	pHelp->level   = lev;
	add_help( pHelp );
    }
    ch->substate = SUB_HELP_EDIT;
    ch->dest_buf = pHelp;
    start_editing( ch, pHelp->text );
}

/*
 * Stupid leading space muncher fix				-Thoric
 */
char *help_fix( char *text )
{
    char *fixed;

    if ( !text )
      return "";
    fixed = strip_cr(text);
    if ( fixed[0] == ' ' )
      fixed[0] = '.';
    return fixed;
}

void do_hset( CHAR_DATA *ch, const char *argument )
{
    HELP_DATA *pHelp;
    char arg1[MAX_INPUT_LENGTH];
    char arg2[MAX_INPUT_LENGTH];

	argument = smash_tilde_copy( argument );
    argument = one_argument( argument, arg1 );
    if ( arg1[0] == '\0' )
    {
	send_to_char( "Sintaxis: hset <campo> [valor] [página ayuda]\n\r",	ch );
	send_to_char( "\n\r",						ch );
	send_to_char( "El campo debe ser uno de:\n\r",			ch );
	send_to_char( "  nivel keyword borrar grabar\n\r",		ch );
	return;
    }

    if ( !str_cmp( arg1, "grabar" ) )
    {
	FILE *fpout;

	log_string_plus( "Salvando help.are...", LOG_NORMAL, LEVEL_GREATER );

	rename( "help.are", "help.are.bak" );
	fclose( fpReserve );
	if ( ( fpout = fopen( "help.are", "w" ) ) == NULL )
	{
	   bug( "hset save: fopen", 0 );
	   perror( "help.are" );
	   fpReserve = fopen( NULL_FILE, "r" );
	   return;
	}

	fprintf( fpout, "#HELPS\n\n" );
	for ( pHelp = first_help; pHelp; pHelp = pHelp->next )
	    fprintf( fpout, "%d %s~\n%s~\n\n",
			pHelp->level, pHelp->keyword, help_fix(pHelp->text) );

	fprintf( fpout, "0 $~\n\n\n#$\n" );
	fclose( fpout );
	fpReserve = fopen( NULL_FILE, "r" );
	send_to_char( "Salvado.\n\r", ch );
	return;
    }
    if ( str_cmp( arg1, "borrar" ) )
	argument = one_argument( argument, arg2 );

    if ( (pHelp = get_help( ch, argument )) == NULL )
    {
	send_to_char( "No puedo encontrar ayuda en ese argumento.\n\r", ch );
	return;
    }
    if ( !str_cmp( arg1, "borrar" ) )
    {
	UNLINK( pHelp, first_help, last_help, next, prev );
	STRFREE( pHelp->text );
	STRFREE( pHelp->keyword );
	DISPOSE( pHelp );
	send_to_char( "Borrado.\n\r", ch );
	return;
    }
    if ( !str_cmp( arg1, "nivel" ) )
    {
	pHelp->level = atoi( arg2 );
	send_to_char( "Ok.\n\r", ch );
	return;
    }
    if ( !str_cmp( arg1, "keyword" ) )
    {
	STRFREE( pHelp->keyword );
	pHelp->keyword = STRALLOC( strupper(arg2) );
	send_to_char( "Ok.\n\r", ch );
	return;
    }

    do_hset( ch, "" );
}

/*
 * Show help topics in a level range				-Thoric
 * Idea suggested by Gorog
 */
void do_hlist( CHAR_DATA *ch, const char *argument )
{
    int min, max, minlimit, maxlimit, cnt;
    char arg[MAX_INPUT_LENGTH];
    HELP_DATA *help;

    maxlimit = get_trust(ch);
    minlimit = maxlimit >= LEVEL_GREATER ? -1 : 0;
    argument = one_argument( argument, arg );
    if ( arg[0] != '\0' )
    {
	min = URANGE( minlimit, atoi(arg), maxlimit );
	if ( argument[0] != '\0' )
	    max = URANGE( min, atoi(argument), maxlimit );
	else
	    max = maxlimit;
    }
    else
    {
	min = minlimit;
	max = maxlimit;
    }
    set_pager_color( AT_GREEN, ch );
    pager_printf( ch, "Ayudas en rangos de nivel %d a %d:\n\r\n\r", min, max );
    for ( cnt = 0, help = first_help; help; help = help->next )
	if ( help->level >= min && help->level <= max )
	{
	    pager_printf( ch, "  %3d %s\n\r", help->level, help->keyword );
	    ++cnt;
	}
    if ( cnt )
	pager_printf( ch, "\n\r%d páginas encontradas.\n\r", cnt );
    else
	send_to_char( "No se ha encontrado ninguna.\n\r", ch );
}

void do_owho(CHAR_DATA *ch, const char *argument) {
	char arg[MAX_STRING_LENGTH];

	if (IS_NPC(ch) || !ch->pcdata->clan) {
		send_to_char("¿Cómo?\n\r", ch);
		return;
	}
	strcpy(arg, argument);
	strcat(arg, " \"");
	strcat(arg, ch->pcdata->clan_name);
	strcat(arg, "\"");
	do_who(ch, arg);
}

/*
 * New do_who with WHO REQUEST, clan, race and homepage support.  -Thoric
 *
 * Latest version of do_who eliminates redundant code by using linked lists.
 * Shows imms separately, indicates guest and retired immortals.
 * Narn, Oct/96
 */
void do_who( CHAR_DATA *ch, const char *argument ) {
	char buf[MAX_STRING_LENGTH];
	char clan_name[MAX_INPUT_LENGTH];
	char invis_str[MAX_INPUT_LENGTH];
	char char_name[MAX_INPUT_LENGTH];
	char extra_title[MAX_STRING_LENGTH];
	char race_text[MAX_INPUT_LENGTH];
	DESCRIPTOR_DATA *d;
	int iRace;
	int iLevelLower;
	int iLevelUpper;
	int nNumber;
	int nMatch;
	bool rgfRace[MAX_RACE];
	bool fRaceRestrict;
	bool fImmortalOnly;
	bool fShowHomepage;
	bool fClanMatch; /* SB who clan */
	CLAN_DATA *pClan = NULL;
	FILE *whoout = NULL;
	int i;
	char *top_ability = NULL;

	/*
#define WT_IMM    0;
#define WT_MORTAL 1;
	 */

	WHO_DATA *cur_who = NULL;
	WHO_DATA *next_who = NULL;
	WHO_DATA *first_mortal = NULL;
	WHO_DATA *first_newbie = NULL;
	WHO_DATA *first_imm = NULL;

	/*
	 * Set default arguments.
	 */
	iLevelLower    = 0;
	iLevelUpper    = MAX_LEVEL;
	fRaceRestrict  = FALSE;
	fImmortalOnly  = FALSE;
	fShowHomepage  = FALSE;
	fClanMatch	   = FALSE; /* SB who clan  */
	for ( iRace = 0; iRace < MAX_RACE; iRace++ )
		rgfRace[iRace] = FALSE;

	/*
	 * Parse arguments.
	 */
	nNumber = 0;
	for ( ;; ) {
		char arg[MAX_STRING_LENGTH];

		argument = one_argument( argument, arg );
		if ( arg[0] == '\0' )
			break;

/*		if ( is_number( arg ) ) {
			switch ( ++nNumber ) {
				case 1: iLevelLower = atoi( arg ); break;
				case 2: iLevelUpper = atoi( arg ); break;
				default:
					send_to_char( "Sólo están permitidos niveles de dos cifras.\n\r", ch );
					return;
			}
		} else {*/
			if ( strlen(arg) < 3 ) {
				send_to_char( "Se un poco más concreto, por favor.\n\r", ch );
				return;
			}
			/*
			 * Look for classes to turn on.
			 */
			if ( !str_cmp( arg, "inm" ) || !str_cmp( arg, "dioses" ) )
				fImmortalOnly = TRUE;
			else
				if ( !str_cmp( arg, "www" ) )
					fShowHomepage = TRUE;
			else		 /* SB who clan (order), guild */
				if  ( ( pClan = get_clan (arg) ) )
					fClanMatch = TRUE;
			else {
				for ( iRace = 0; iRace < MAX_RACE; iRace++ ) {
					if ( !str_cmp( arg, race_table[iRace].race_name ) ) {
						rgfRace[iRace] = TRUE;
						break;
					}
				}
				if ( iRace != MAX_RACE )
					fRaceRestrict = TRUE;
				if ( iRace == MAX_RACE && fClanMatch == FALSE ) {
					send_to_char( "Eso no es una especie u organización.\n\r", ch );
					return;
				}
			}
		//}
	}

	/*
	 * Now find matching chars.
	 */
	nMatch = 0;
	buf[0] = '\0';
	if ( ch )
		set_pager_color( AT_GREEN, ch );
	else {
		if ( fShowHomepage )
			whoout = fopen( WEBWHO_FILE, "w" );
		else
			whoout = fopen( WHO_FILE, "w" );
	}

	/* start from last to first to get it in the proper order */
	for ( d = last_descriptor; d; d = d->prev ) {
		CHAR_DATA *wch;
		char const *race;

		if ( (d->connected != CON_PLAYING && d->connected != CON_EDITING)
			|| ( !can_see( ch, d->character ) && IS_IMMORTAL( d->character ) )
			|| d->original)
			continue;
		wch   = d->original ? d->original : d->character;
		if ( wch->top_level < iLevelLower
			||   wch->top_level > iLevelUpper
			|| ( fImmortalOnly  && wch->top_level < LEVEL_IMMORTAL )
			|| ( fRaceRestrict && !rgfRace[wch->race] )
			|| ( fClanMatch && ( pClan != wch->pcdata->clan ))  /* SB */ )
			continue;

		nMatch++;

		if ( fShowHomepage && wch->pcdata->homepage && wch->pcdata->homepage[0] != '\0' )
			sprintf( char_name, "<A HREF=\"%s\">%s</A>", show_tilde( wch->pcdata->homepage ), wch->name );
		else
			strcpy( char_name, "" );
		if (IS_IMMORTAL(ch)) {
			for (i=0; i<MAX_ABILITY; i++) {
				if (wch->skill_level[i] == wch->top_level) {
					top_ability = ability_name[i];
					break;
				}
			}
			sprintf( race_text, "&C%d &p%s &O%s", wch->top_level, top_ability?top_ability:"", race_table[wch->race].race_name);
		} else
			sprintf( race_text, "&O%s", race_table[wch->race].race_name);
		race = race_text;

		switch ( wch->top_level ) {
			default: break;
			case 200: race = "Entidad";	break;
			case MAX_LEVEL -  0: race = "Presidente";	break;
			case MAX_LEVEL -  1: race = "Ejecutivo";	break;
			case MAX_LEVEL -  2: race = "Senador";	break;
			case MAX_LEVEL -  3: race = "Ingeniero";	break;
			case MAX_LEVEL -  4: race = "Retirado";	break;
		}

		if ( !nifty_is_name(wch->name, wch->pcdata->title) && ch->top_level > wch->top_level )
			sprintf( extra_title , "&w [%s]" , wch->name );
		else
			strcpy(extra_title, "&w");

		if ( IS_RETIRED( wch ) )
			race = "Retirado";
		else if ( IS_GUEST( wch ) )
			race = "Invitado";
		else if ( wch->pcdata->rank && wch->pcdata->rank[0] != '\0' )
			race = wch->pcdata->rank;

		if ( wch->pcdata->clan ) {
			CLAN_DATA *pclan = wch->pcdata->clan;

			strcpy( clan_name, " (" );
			if (fClanMatch)
				strcat(clan_name, pclan->ranknames[wch->pcdata->clan_rank]);
			else
				strcat( clan_name, pclan->name );
			strcat( clan_name, ")" );
		}
		else
			clan_name[0] = '\0';


		if ( IS_SET(wch->act, PLR_WIZINVIS) )
			sprintf( invis_str, "(%d) ", wch->pcdata->wizinvis );
		else
			invis_str[0] = '\0';

		sprintf( buf, "%s %s%s%s%s %s%s%s\n\r",
				race,
				invis_str,
				IS_SET(wch->act, PLR_AFK) ? "[AFK] " : "",
				char_name,
				wch->pcdata->title,
				extra_title,
				clan_name,
				IS_SET(wch->act, PLR_KILLER) ? "&R [Buscado por Asesinato]&W" : "&W" );

		/*
		 * This is where the old code would display the found player to the ch.
		 * What we do instead is put the found data into a linked list
		 */

		/* First make the structure. */
		CREATE( cur_who, WHO_DATA, 1 );
		cur_who->text = str_dup( buf );
		if ( IS_IMMORTAL( wch ) )
			cur_who->type = WT_IMM;
		else if ( get_trust( wch ) <= 5 )
			cur_who->type = WT_NEWBIE;
		else
			cur_who->type = WT_MORTAL;

		/* Then put it into the appropriate list. */
		switch ( cur_who->type )
		{
			case WT_MORTAL:
				cur_who->next = first_mortal;
				first_mortal = cur_who;
				break;
			case WT_IMM:
				cur_who->next = first_imm;
				first_imm = cur_who;
				break;
			case WT_NEWBIE:
				cur_who->next = first_newbie;
				first_newbie = cur_who;
				break;

		}

	}


	/* Ok, now we have three separate linked lists and what remains is to
	 * display the information and clean up.
	 */

	/* Deadly list removed for swr ... now only 2 lists */

	if ( first_newbie )
	{
		if ( !ch )
			fprintf( whoout,"\n\r----------------------------------[ Nuevos Habitantes ]----------------------------\n\r\n\r" );
		else
			send_to_pager( "\n\r&G----------------------------------[ Nuevos Habitantes ]----------------------------&W\n\r\n\r", ch );
	}

	for ( cur_who = first_newbie; cur_who; cur_who = next_who )
	{
		if ( !ch )
			fprintf( whoout, "%s", cur_who->text );
		else
			send_to_pager( cur_who->text, ch );
		next_who = cur_who->next;
		DISPOSE( cur_who->text );
		DISPOSE( cur_who );
	}


	if ( first_mortal )
	{
		if ( !ch )
			fprintf( whoout,"\n\r-----------------------------[ Habitantes de la Galaxia ]-------------------------\n\r\n\r" );
		else
			send_to_pager( "\n\r&G-----------------------------[ Habitantes de la Galaxia ]-------------------------&W\n\r\n\r", ch );
	}

	for ( cur_who = first_mortal; cur_who; cur_who = next_who )
	{
		if ( !ch )
			fprintf( whoout, "%s", cur_who->text );
		else
			send_to_pager( cur_who->text, ch );
		next_who = cur_who->next;
		DISPOSE( cur_who->text );
		DISPOSE( cur_who );
	}

	if ( first_imm )
	{
		if ( !ch )
			fprintf( whoout, "\n\r-------------------------------[ Seres Omnipresentes ]-------------------------\n\r\n\r" );
		else
			send_to_pager(  "\n\r&G-------------------------------[ Seres Omnipresentes ]--------------------------&W\n\r\n\r", ch );
	}

	for ( cur_who = first_imm; cur_who; cur_who = next_who )
	{
		if ( !ch )
			fprintf( whoout, "%s", cur_who->text );
		else
			send_to_pager( cur_who->text, ch );
		next_who = cur_who->next;
		DISPOSE( cur_who->text );
		DISPOSE( cur_who );
	}

	if ( !ch )
	{
		fprintf( whoout, "%d jugador%s.\n\r", nMatch, nMatch == 1 ? "" : "es" );
		fclose( whoout );
		return;
	}

	set_char_color( AT_YELLOW, ch );
	ch_printf( ch, "%d jugador%s.\n\r", nMatch, nMatch == 1 ? "" : "es" );
	return;
}


void do_compare( CHAR_DATA *ch, const char *argument )
{
    char arg1[MAX_INPUT_LENGTH];
    char arg2[MAX_INPUT_LENGTH];
    OBJ_DATA *obj1;
    OBJ_DATA *obj2;
    int value1;
    int value2;
    char *msg;

    argument = one_argument( argument, arg1 );
    argument = one_argument( argument, arg2 );
    if ( arg1[0] == '\0' )
    {
	send_to_char( "¿Qué dos cosas quieres comparar?\n\r", ch );
	return;
    }

    if ( ( obj1 = get_obj_carry( ch, arg1 ) ) == NULL )
    {
	send_to_char( "No tienes ese objeto.\n\r", ch );
	return;
    }

    if ( arg2[0] == '\0' )
    {
	for ( obj2 = ch->first_carrying; obj2; obj2 = obj2->next_content )
	{
	    if ( obj2->wear_loc != WEAR_NONE
	    &&   can_see_obj( ch, obj2 )
	    &&   obj1->item_type == obj2->item_type
	    && ( obj1->wear_flags & obj2->wear_flags & ~ITEM_TAKE) != 0 )
		break;
	}

	if ( !obj2 )
	{
	    send_to_char( "No llevas nada que se pueda comparar.\n\r", ch );
	    return;
	}
    }
    else
    {
	if ( ( obj2 = get_obj_carry( ch, arg2 ) ) == NULL )
	{
	    send_to_char( "No tienes ese objeto.\n\r", ch );
	    return;
	}
    }

    msg		= NULL;
    value1	= 0;
    value2	= 0;

    if ( obj1 == obj2 )
    {
	msg = "Comparas $p consigo mismo.  Parece ser idéntico.";
    }
    else if ( obj1->item_type != obj2->item_type )
    {
	msg = "No puedes comparar $p y $P.";
    }
    else
    {
	switch ( obj1->item_type )
	{
	default:
	    msg = "No puedes comparar $p y $P.";
	    break;

	case ITEM_ARMORMETAL:
	    value1 = obj1->value[0];
	    value2 = obj2->value[0];
	    break;

	case ITEM_ARMORTELA:
	    value1 = obj1->value[0];
	    value2 = obj2->value[0];
	    break;

	case ITEM_ARMOROTRO:
	    value1 = obj1->value[0];
	    value2 = obj2->value[0];
	    break;

	case ITEM_WEAPON:
	    value1 = obj1->value[1] + obj1->value[2];
	    value2 = obj2->value[1] + obj2->value[2];
	    break;
	}
    }

    if ( !msg )
    {
	     if ( value1 == value2 ) msg = "$p y $P parecen iguales.";
	else if ( value1  > value2 ) msg = "$p parece mejor que $P.";
	else                         msg = "$p parece peor que $P.";
    }

    act( AT_PLAIN, msg, ch, obj1, obj2, TO_CHAR );
    return;
}

void do_where( CHAR_DATA *ch, const char *argument )
{
	char arg[MAX_INPUT_LENGTH];
	CHAR_DATA *victim;
	DESCRIPTOR_DATA *d;
	bool found;

	if (get_trust(ch) < LEVEL_IMMORTAL) {
		send_to_char( "Si la vida fuera realmente tan simple...\n\r" , ch);
		return;
	}

	one_argument( argument, arg );
	set_pager_color( AT_PERSON, ch );
	if ( arg[0] == '\0' ) {
		if (get_trust(ch) >= LEVEL_IMMORTAL)
			send_to_pager( "Jugadores conectados en:\n\r", ch );
		else
			pager_printf( ch, "Jugadores cerca tuyo en %s:\n\r", ch->in_room->area->name );
		found = FALSE;
		for ( d = first_descriptor; d; d = d->next )
			if ( (d->connected == CON_PLAYING || d->connected == CON_EDITING )
				&& ( victim = d->character ) != NULL
				&&   !IS_NPC(victim) && victim->in_room && (victim->in_room->area == ch->in_room->area || get_trust(ch) >= LEVEL_IMMORTAL )
				&&   can_see( ch, victim ) )
		{
			found = TRUE;
			if (get_trust(ch)>=LEVEL_IMMORTAL)
				pager_printf (ch, "%-20s (%dhp) %-25s (%d) (%-25s)\n\r", victim->name, victim->hit, victim->in_room->name, victim->in_room->vnum, victim->in_room->area->name);
			else
				pager_printf( ch, "%-28s %s\n\r", victim->name, victim->in_room->name );
		}
		if ( !found )
			send_to_char( "Ninguno.\n\r", ch );
	}
	else
	{
		found = FALSE;
		for ( victim = first_char; victim; victim = victim->next )
			if ( victim->in_room &&
				((victim->in_room->area == ch->in_room->area && !IS_AFFECTED(victim, AFF_HIDE) && !IS_AFFECTED(victim, AFF_SNEAK)) || get_trust(ch)>=LEVEL_IMMORTAL)
				&&   can_see( ch, victim ) && is_name( arg, victim->name ) )
		{
			found = TRUE;
			pager_printf( ch, "%-28s %s\n\r",
						 PERS(victim, ch), victim->in_room->name );
			break;
		}
		if ( !found )
			act( AT_PLAIN, "No encuentras ningún $T.", ch, NULL, arg, TO_CHAR );
	}

	return;
}

void do_consider( CHAR_DATA *ch, const char *argument ) {
	char arg[MAX_INPUT_LENGTH];
	CHAR_DATA *victim;
	char *msg;
	int diff;

	one_argument( argument, arg );

	if ( arg[0] == '\0' ) {
		send_to_char( "¿A quién estas pensando matar?\n\r", ch );
		return;
	}

	if ( ( victim = get_char_room( ch, arg ) ) == NULL ) {
		send_to_char( "No está aquí.\n\r", ch );
		return;
	}

	diff = ( victim->skill_level[COMBAT_ABILITY] - ch->skill_level[COMBAT_ABILITY]) * 10 ;
	diff += (int) (victim->max_hit - ch->max_hit) / 10;

	if ( diff <= -200) msg = "¡$N parece inofensivo!";
	else if ( diff <= -150) msg = "¡Seguro que $N saldría huyendo!";
	else if ( diff <= -100) msg = "¡Tan fácil como matar una rata con un cañón!";
	else if ( diff <=  -50) msg = "$N es un cobarde.";
	else if ( diff <=    0) msg = "$N se ve más débil que tú.";
	else if ( diff <=   50) msg = "$N se ve tan fuerte como tú.";
	else if ( diff <=  100) msg = "Necesitarías algo de suerte...";
	else if ( diff <=  150) msg = "¡Necesitarías mucha suerte y un arma realmente potente!";
	else if ( diff <=  200) msg = "¿Y por qué no atacas a un crucero galáctico con un vibrofilo?";
	else                    msg = "¡¡¡$N podria destrozarte!!!";
	act( AT_CONSIDER, msg, ch, NULL, victim, TO_CHAR );

	return;
}



/*
 * Place any skill types you don't want them to be able to practice
 * normally in this list.  Separate each with a space.
 * (Uses an is_name check). -- Altrag
 */
#define CANT_PRAC "Tongue"

void do_practice( CHAR_DATA *ch, const char *argument ) {
	char buf[MAX_STRING_LENGTH];
	char ability_colors[MAX_ABILITY] = "rzOg";
	int sn, flag = 0;
	int ability = MAX_ABILITY;

	if ( IS_NPC(ch) )
		return;

	if (argument[0] != '\0')
	{
		for (ability = 0; ability < MAX_ABILITY; ability++)
		{
			if (!str_cmp(argument, ability_name[ability]))
			{
				flag = 1;
				for ( sn = 0; sn < top_sn; sn++ )
				{
					if ( !skill_table[sn]->name )
						break;
					if ( skill_table[sn]->skill_level[ability] == 0)
						continue;
					if ( ch->pcdata->learned[sn] <= 0 && ch->skill_level[ability] < skill_table[sn]->skill_level[ability] )
						continue;
					if ( ch->pcdata->learned[sn] == 0 &&   SPELL_FLAG(skill_table[sn], SF_SECRETSKILL) )
						continue;
					pager_printf( ch, "&%c%20s &w%3d%%  \n\r", ability_colors[ability],
						 skill_table[sn]->name, ch->pcdata->learned[sn] );
				}
			}
		}

	}
	if ( flag == 1)
			return;
	if ( argument[0] == '\0' || ability < MAX_ABILITY )
	{
		int	col;
		sh_int	lasttype = 0, cnt, lastguild = -1;

		col = 0; cnt = 1;	lasttype = SKILL_SPELL;
		set_pager_color( AT_MAGIC, ch );
		for ( ability = 0 ; ability < MAX_ABILITY ; ability++ )
		{
			for ( sn = 0; sn < top_sn; sn++ )
			{
				if ( !skill_table[sn]->name )
					break;

				if ( skill_table[sn]->skill_level[ability] == 0)
					continue;

				if ( strcmp(skill_table[sn]->name, "reserved") == 0 && ( IS_IMMORTAL(ch) ) ) {
					if ( col % 3 != 0 )
						send_to_pager( "\n\r", ch );
					send_to_pager(
								  "&w----------------------------------[ ** ]-----------------------------------\n\r", ch);
					col = 0;
				}
				if (skill_table[sn]->type != lasttype || ability != lastguild)
				{
					if ( !cnt )
						send_to_pager( "                                &w(ninguno)\n\r", ch );
					else if ( col % 3 != 0 )
						send_to_pager( "\n\r", ch );
					if ( skill_table[sn]->type > 1 )
					{
						pager_printf (ch, "\n\r&w---------------------------------- %s%s de %s ----------------------------------\n\n\r",
									  skill_tname[skill_table[sn]->type],
									  !str_cmp(skill_tname[skill_table[sn]->type], "Habilidad")?"es":"s",
									  ability_name[ability]);
						col = cnt = 0;
					}
				}
				lasttype = skill_table[sn]->type;
				lastguild = ability;
				if (  ch->pcdata->learned[sn] <= 0  &&  ch->skill_level[ability] < skill_table[sn]->skill_level[ability] )
					continue;

				if ( ch->pcdata->learned[sn] == 0
					&&   SPELL_FLAG(skill_table[sn], SF_SECRETSKILL) )
					continue;
				++cnt;
				pager_printf( ch, "&%c%20s &w%3d%%  ", ability_colors[ability],
							 skill_table[sn]->name, ch->pcdata->learned[sn] );
				if ( ++col % 3 == 0 )
					send_to_pager( "\n\r", ch );
			}
		}
	} else {
		CHAR_DATA *mob;
		int adept = 0;
		bool can_prac = TRUE;
		int ab;

		if ( !IS_AWAKE(ch) ) {
			send_to_char( "¿En tus sueños o qué?\n\r", ch );
			return;
		}

		for ( mob = ch->in_room->first_person; mob; mob = mob->next_in_room )
			if ( IS_NPC(mob) && IS_SET(mob->act, ACT_PRACTICE) )
			break;

		if ( !mob ) {
			send_to_char( "No puedes hacer eso aquí.\n\r", ch );
			return;
		}

		sn = skill_lookup( argument );
		if ( sn == -1 ) {
		act( AT_TELL, "$n te cuenta 'Nunca he oído hablar de eso...'",
			mob, NULL, ch, TO_VICT );
		return;
		}
		for (ability = 0; ability < MAX_ABILITY; ability++) {
			if (ch->skill_level[ability] >= skill_table[sn]->skill_level[ability] &&
				    skill_table[sn]->skill_adept[ability] > adept) {
				adept = skill_table[sn]->skill_adept[ability];
				ab = ability;
			}
		}
		if (!adept && can_prac && !IS_NPC(ch)) {
			act( AT_TELL, "$n te cuenta 'Aún no estás preparado para aprenderlo...'",
				mob, NULL, ch, TO_VICT );
			return;
		}
		if ( is_name( skill_tname[skill_table[sn]->type], CANT_PRAC ) ) {
			act( AT_TELL, "$n te cuenta 'No sé cómo enseñarte eso.'",
				mob, NULL, ch, TO_VICT );
			return;
		}

		/*
		 * Skill requires a special teacher
		 */
		if ( skill_table[sn]->teachers && skill_table[sn]->teachers[0] != '\0' ) {
			sprintf( buf, "%d", mob->pIndexData->vnum );
			if ( !is_name( buf, skill_table[sn]->teachers ) ) {
				act( AT_TELL, "$n te cuenta 'No sé cómo enseñarte eso.'",
					mob, NULL, ch, TO_VICT );
				return;
			}
		} else {
			act( AT_TELL, "$n te cuenta 'No sé cómo enseñarte eso.'",
				mob, NULL, ch, TO_VICT );
			return;
		}

		adept *= 0.2;

		if ( ch->pcdata->learned[sn] >= adept ) {
			sprintf( buf, "$n te cuenta 'Te he enseñado todo lo que podía sobre %s.'",
					skill_table[sn]->name );
			act( AT_TELL, buf, mob, NULL, ch, TO_VICT );
			act( AT_TELL, "$n te cuenta 'Ahora deberás practicarlo por tu cuenta...'",
				mob, NULL, ch, TO_VICT );
		} else {
			if (!pay(ch, skill_table[sn]->skill_level[ab]*10, PAYMENT_CASH | PAYMENT_ELECTRONIC)) {
				return;
			}
			ch->pcdata->learned[sn] += ms_app[get_curr_ms(ch)].learn;
			act( AT_ACTION, "Practicas $T.",
				ch, NULL, skill_table[sn]->name, TO_CHAR );
			act( AT_ACTION, "$n practica $T.",
				ch, NULL, skill_table[sn]->name, TO_ROOM );
			if ( ch->pcdata->learned[sn] >= adept ) {
				ch->pcdata->learned[sn] = adept;
				act( AT_TELL,
					"$n te cuenta 'Ahora deberás practicarlo por tu cuenta...'",
					mob, NULL, ch, TO_VICT );
			}
		}
	}
	return;
}

void do_teach( CHAR_DATA *ch, const char *argument )
{
	char buf[MAX_STRING_LENGTH];
	int sn;
	char arg[MAX_INPUT_LENGTH];
	int ability;

	if ( IS_NPC(ch) )
		return;

	argument = one_argument(argument, arg);

	if ( argument[0] == '\0' )
	{
		send_to_char( "¿Qué quieres enseñar, y a quién?\n\r", ch );
		return;
	}
	else
	{
		CHAR_DATA *victim;
		int adept;

		if ( !IS_AWAKE(ch) )
		{
			send_to_char( "¿En tus sueños o qué?\n\r", ch );
			return;
		}

		if ( ( victim = get_char_room( ch, arg ) ) == NULL )
		{
			send_to_char( "Eso no parece estar aquí...\n\r", ch );
			return;
		}

		if (IS_NPC(victim))
		{
			send_to_char( "¡No puedes enseñarle eso!\n\r", ch );
			return;
		}

		sn = skill_lookup( argument );

		if ( sn == -1 )
		{
			act( AT_TELL, "No tienes ni idea de qué es eso.",
			    victim, NULL, ch, TO_VICT );
			return;
		}
		for (ability = 0; ability < MAX_ABILITY; ability++) {
			if (victim->skill_level[ability] >= skill_table[sn]->skill_level[ability] &&
				    skill_table[sn]->skill_adept[ability] > 0) {
				break;
			}
		}
		if (ability == MAX_ABILITY) {
			act( AT_TELL, "$n no está preparado para aprender eso aún.", victim, NULL, ch, TO_VICT );
			return;
		}

		if ( is_name( skill_tname[skill_table[sn]->type], CANT_PRAC ) )
		{
			act( AT_TELL, "No eres capaz de enseñarle esa habilidad.",
			    victim, NULL, ch, TO_VICT );
			return;
		}

		adept = 20;

		if ( victim->pcdata->learned[sn] >= adept )
		{
			act( AT_TELL, "$n debe practicarlo por su cuenta.", victim, NULL, ch, TO_VICT );
			return;
		}
		if ( ch->pcdata->learned[sn] < 100 )
		{
			act( AT_TELL, "Debes perfeccionarte a ti mismo antes de enseñar a otros.", victim, NULL, ch, TO_VICT );
			return;
		}
		else
		{
			victim->pcdata->learned[sn] += ms_app[get_curr_ms(ch)].learn;
			sprintf( buf, "Enseñas a %s $T.", victim->name );
			act( AT_ACTION, buf,
			    ch, NULL, skill_table[sn]->name, TO_CHAR );
			sprintf( buf, "%s te enseña $T.", ch->name );
			act( AT_ACTION, buf,
			    victim, NULL, skill_table[sn]->name, TO_CHAR );
		}
	}
	return;
}


void do_wimpy( CHAR_DATA *ch, const char *argument )
{
    char arg[MAX_INPUT_LENGTH];
    int wimpy;

    one_argument( argument, arg );

    if ( arg[0] == '\0' )
	wimpy = (int) ch->max_hit / 5;
    else
	wimpy = atoi( arg );

    if ( wimpy < 0 )
    {
	send_to_char( "Tu coraje excede tu sabiduría.\n\r", ch );
	return;
    }

    if ( wimpy > ch->max_hit )
    {
	send_to_char( "Tanta cobardía te enferma.\n\r", ch );
	return;
    }

    ch->wimpy	= wimpy;
    ch_printf( ch, "Huida fijada en %d puntos.\n\r", wimpy );
    return;
}

void do_socials( CHAR_DATA *ch, const char *argument )
{
    int iHash;
    int col = 0;
    SOCIALTYPE *social;

    set_pager_color( AT_PLAIN, ch );
    for ( iHash = 0; iHash < 27; iHash++ )
	for ( social = social_index[iHash]; social; social = social->next )
	{
	    pager_printf( ch, "%-12s", social->name );
	    if ( ++col % 6 == 0 )
		send_to_pager( "\n\r", ch );
	}

    if ( col % 6 != 0 )
	send_to_pager( "\n\r", ch );
    return;
}


void do_commands( CHAR_DATA *ch, const char *argument )
{
    int col;
    bool found;
    int hash;
    CMDTYPE *command;

    col = 0;
    set_pager_color( AT_PLAIN, ch );
    if ( argument[0] == '\0' )
    {
	for ( hash = 0; hash < 126; hash++ )
	    for ( command = command_hash[hash]; command; command = command->next )
		if ( command->level <  LEVEL_HERO
		&&   command->level <= get_trust( ch )
		&&  (command->name[0] != 'm'
		&&   command->name[1] != 'p') )
		{
		    pager_printf( ch, "%-12s", command->name );
		    if ( ++col % 6 == 0 )
			send_to_pager( "\n\r", ch );
		}
	if ( col % 6 != 0 )
	    send_to_pager( "\n\r", ch );
    }
    else
    {
	found = FALSE;
	for ( hash = 0; hash < 126; hash++ )
	    for ( command = command_hash[hash]; command; command = command->next )
		if ( command->level <  LEVEL_HERO
		&&   command->level <= get_trust( ch )
		&&  !str_prefix(argument, command->name)
		&&  (command->name[0] != 'm'
		&&   command->name[1] != 'p') )
		{
		    pager_printf( ch, "%-12s", command->name );
		    found = TRUE;
		    if ( ++col % 6 == 0 )
			send_to_pager( "\n\r", ch );
		}

	if ( col % 6 != 0 )
	    send_to_pager( "\n\r", ch );
	if ( !found )
	    ch_printf( ch, "No se ha encontrado ningún comando bajo %s.\n\r", argument);
    }
    return;
}


void do_channels( CHAR_DATA *ch, const char *argument )
{
    char arg[MAX_INPUT_LENGTH];

    one_argument( argument, arg );

    if ( arg[0] == '\0' )
    {
	if ( !IS_NPC(ch) && IS_SET(ch->act, PLR_SILENCE) )
	{
	    send_to_char( "Estás silenciado.\n\r", ch );
	    return;
	}

	send_to_char( "Canales:", ch );

        if ( get_trust( ch ) > 2 && !NOT_AUTHED( ch ) )
        {
	 send_to_char( !IS_SET(ch->deaf, CHANNEL_AUCTION)
	    ? " +SUBASTAR"
	    : " -subastar",
	    ch );
        }

	send_to_char( !IS_SET(ch->deaf, CHANNEL_CHAT)
	    ? " +CHAT"
	    : " -chat",
	    ch );

        send_to_char( !IS_SET(ch->deaf, CHANNEL_OOC)
	    ? " +OFFROL"
	    : " -offrol",
	    ch );

	if ( !IS_NPC( ch ) && ch->pcdata->clan )
	{
 	    send_to_char( !IS_SET(ch->deaf, CHANNEL_CLAN)
	        ? " +CLAN"
	        : " -clan",
	        ch );
	}


	send_to_char( !IS_SET(ch->deaf, CHANNEL_QUEST)
	    ? " +QUEST"
	    : " -quest",
	    ch );

	send_to_char( !IS_SET( ch->deaf, CHANNEL_TELLS )
	    ? " +CONTAR"
	    : " -contar",
	    ch );

        send_to_char( !IS_SET( ch->deaf, CHANNEL_WARTALK )
            ? " +GUERRA"
            : " -guerra",
            ch );

	if ( IS_HERO(ch) )
	{
	    send_to_char( !IS_SET(ch->deaf, CHANNEL_AVTALK)
		? " +AVATAR"
		: " -avatar",
		ch );
	}

	if ( IS_IMMORTAL(ch) )
	{
	    send_to_char( !IS_SET(ch->deaf, CHANNEL_IMMTALK)
		? " +INMCHARLAR"
		: " -inmcharlar",
		ch );

	    send_to_char( !IS_SET(ch->deaf, CHANNEL_PRAY)
		? " +REZAR"
		: " -rezar",
		ch );
	}

	send_to_char( !IS_SET(ch->deaf, CHANNEL_MUSIC)
	    ? " +MUSICA"
	    : " -musica",
	    ch );

	send_to_char( !IS_SET(ch->deaf, CHANNEL_ASK)
	    ? " +PREGUNTAR"
	    : " -preguntar",
	    ch );

	send_to_char( !IS_SET(ch->deaf, CHANNEL_SHOUT)
	    ? " +GRITAR"
	    : " -gritar",
	    ch );

	send_to_char( !IS_SET(ch->deaf, CHANNEL_YELL)
	    ? " +CHILLAR"
	    : " -chillar",
	    ch );

	if ( IS_IMMORTAL(ch) )
	{
	    send_to_char( !IS_SET(ch->deaf, CHANNEL_MONITOR)
		? " +MONITOR"
		: " -monitor",
		ch );
	}

	send_to_char( !IS_SET(ch->deaf, CHANNEL_NEWBIE)
	      	? " +NOVATO"
		: " -novato",
		ch );

	if ( get_trust(ch) >= sysdata.log_level )
	{
	    send_to_char( !IS_SET(ch->deaf, CHANNEL_LOG)
		? " +LOG"
		: " -log",
		ch );

	    send_to_char( !IS_SET(ch->deaf, CHANNEL_BUILD)
		? " +BUILD"
		: " -build",
		ch );

            send_to_char( !IS_SET(ch->deaf, CHANNEL_COMM)
	        ? " +COM"
	        : " -com",
	        ch );
	}
	send_to_char( !IS_SET(ch->deaf, CHANNEL_INFO)?" +INFO":" -info", ch);
	send_to_char( ".\n\r", ch );
    }
    else
    {
	bool fClear;
	bool ClearAll;
	int bit;

        bit=0;
        ClearAll = FALSE;

	     if ( arg[0] == '+' ) fClear = TRUE;
	else if ( arg[0] == '-' ) fClear = FALSE;
	else
	{
	    send_to_char( "Canales -canal o +canal?\n\r", ch );
	    return;
	}

	     if ( !str_cmp( arg+1, "subastar"  ) ) bit = CHANNEL_AUCTION;
	else if ( !str_cmp( arg+1, "chat"     ) ) bit = CHANNEL_CHAT;
	else if ( !str_cmp( arg+1, "offrolf"      ) ) bit = CHANNEL_OOC;
	else if ( !str_cmp( arg+1, "clan"     ) ) bit = CHANNEL_CLAN;
        else if ( !str_cmp( arg+1, "gremio"    ) ) bit = CHANNEL_GUILD;
	else if ( !str_cmp( arg+1, "quest"    ) ) bit = CHANNEL_QUEST;
	else if ( !str_cmp( arg+1, "contar"    ) ) bit = CHANNEL_TELLS;
	else if ( !str_cmp( arg+1, "inmcharlar"  ) ) bit = CHANNEL_IMMTALK;
	else if ( !str_cmp( arg+1, "log"      ) ) bit = CHANNEL_LOG;
	else if ( !str_cmp( arg+1, "build"    ) ) bit = CHANNEL_BUILD;
	else if ( !str_cmp( arg+1, "rezar"     ) ) bit = CHANNEL_PRAY;
	else if ( !str_cmp( arg+1, "avatar"   ) ) bit = CHANNEL_AVTALK;
	else if ( !str_cmp( arg+1, "monitor"  ) ) bit = CHANNEL_MONITOR;
	else if ( !str_cmp( arg+1, "novato"   ) ) bit = CHANNEL_NEWBIE;
	else if ( !str_cmp( arg+1, "musica"    ) ) bit = CHANNEL_MUSIC;
	else if ( !str_cmp( arg+1, "preguntar"      ) ) bit = CHANNEL_ASK;
	else if ( !str_cmp( arg+1, "gritar"    ) ) bit = CHANNEL_SHOUT;
	else if ( !str_cmp( arg+1, "chillar"     ) ) bit = CHANNEL_YELL;
	else if ( !str_cmp( arg+1, "com"     ) ) bit = CHANNEL_COMM;
	else if ( !str_cmp( arg+1, "ordencharlar"    ) ) bit = CHANNEL_ORDER;
    else if ( !str_cmp( arg+1, "guerra"  ) ) bit = CHANNEL_WARTALK;
	else if ( !str_cmp( arg+1, "info" ) ) bit = CHANNEL_INFO;
	else if ( !str_cmp( arg+1, "todos"      ) ) ClearAll = TRUE;
	else
	{
	    send_to_char( "¿Activar o desactivar qué canal?\n\r", ch );
	    return;
	}

	if (( fClear ) && ( ClearAll ))
	{
            REMOVE_BIT (ch->deaf, CHANNEL_AUCTION);
            REMOVE_BIT (ch->deaf, CHANNEL_CHAT);
            REMOVE_BIT (ch->deaf, CHANNEL_QUEST);
       /*     REMOVE_BIT (ch->deaf, CHANNEL_IMMTALK); */
            REMOVE_BIT (ch->deaf, CHANNEL_PRAY);
            REMOVE_BIT (ch->deaf, CHANNEL_MUSIC);
            REMOVE_BIT (ch->deaf, CHANNEL_ASK);
            REMOVE_BIT (ch->deaf, CHANNEL_SHOUT);
            REMOVE_BIT (ch->deaf, CHANNEL_YELL);

       /*     if (ch->pcdata->clan)
              REMOVE_BIT (ch->deaf, CHANNEL_CLAN);


            if (ch->pcdata->guild)
              REMOVE_BIT (ch->deaf, CHANNEL_GUILD);
       */
            if (ch->top_level >= LEVEL_IMMORTAL)
              REMOVE_BIT (ch->deaf, CHANNEL_AVTALK);

	    if (ch->top_level >= sysdata.log_level )
	      REMOVE_BIT (ch->deaf, CHANNEL_COMM);
			REMOVE_BIT(ch->deaf, CHANNEL_INFO);
        } else if ((!fClear) && (ClearAll))
        {
            SET_BIT (ch->deaf, CHANNEL_AUCTION);
            SET_BIT (ch->deaf, CHANNEL_CHAT);
            SET_BIT (ch->deaf, CHANNEL_QUEST);
       /*     SET_BIT (ch->deaf, CHANNEL_IMMTALK); */
            SET_BIT (ch->deaf, CHANNEL_PRAY);
            SET_BIT (ch->deaf, CHANNEL_MUSIC);
            SET_BIT (ch->deaf, CHANNEL_ASK);
            SET_BIT (ch->deaf, CHANNEL_SHOUT);
            SET_BIT (ch->deaf, CHANNEL_YELL);
			SET_BIT (ch->deaf, CHANNEL_INFO);

            if (ch->top_level >= LEVEL_IMMORTAL)
              SET_BIT (ch->deaf, CHANNEL_AVTALK);

	    if (ch->top_level >= sysdata.log_level)
	      SET_BIT (ch->deaf, CHANNEL_COMM);

         } else if (fClear)
         {
	    REMOVE_BIT (ch->deaf, bit);
         } else
         {
	    SET_BIT    (ch->deaf, bit);
         }

	  send_to_char( "Ok.\n\r", ch );
    }

    return;
}


/*
 * display WIZLIST file						-Thoric
 */
void do_wizlist( CHAR_DATA *ch, const char *argument )
{
    set_pager_color( AT_IMMORT, ch );
    show_file( ch, WIZLIST_FILE );
}

void do_accesibilidad(CHAR_DATA *ch, const char *argument) {
	char arg[MAX_INPUT_LENGTH];

	if ( IS_NPC(ch) )
		return;

	one_argument( argument, arg );
	set_char_color( AT_WHITE, ch );
	if ( arg[0] == '\0' ) {
		send_to_char(  "[Palabra clave] Opción\n\r", ch );
		send_to_char(IS_SET(ch->pcdata->flags, PCFLAG_ACC_SALIDAS)? "[+SALIDAS     ] Se muestran las salidas en formato reducido.\n\r"
					 : "[-salidas     ] Se muestran las salidas con el nombre del lugar a donde van.\n\r", ch );
		send_to_char(IS_SET(ch->pcdata->flags, PCFLAG_ACC_NAVES)? "[+NAVES       ] No se mostrarán las naves al entrar en un sitio.\n\r"
					 : "[-naves       ] La lista de naves en un sitio se muestra normalmente.\n\r", ch );
		send_to_char(IS_SET(ch->pcdata->flags, PCFLAG_ACC_MOBS)? "[+MOBS        ] Se muestran los mobs antes que los otros elementos de un sitio.\n\r"
					 : "[-mobs        ] Se muestran los mobs al final de la información de un sitio.\n\r", ch );
		send_to_char(IS_SET(ch->pcdata->flags, PCFLAG_ACC_VUELO)? "[+VUELO       ] No saldrán mensajes de velocidad y coordenadas al volar.\n\r"
					 : "[-vuelo       ] Saldrán mensajes de velocidad y coordenadas al volar.\n\r", ch );
		send_to_char(IS_SET(ch->pcdata->flags, PCFLAG_ACC_PUNTUACION)? "[+PUNTUACIÓN  ] Se mostrará la puntuación en formato reducido.\n\r"
					 : "[-puntuación  ] Se mostrará la puntuación en formato completo.\n\r", ch );
	} else {
		bool fSet;
		int bit = 0;

		if ( arg[0] == '+' ) fSet = TRUE;
		else if ( arg[0] == '-' ) fSet = FALSE;
		else {
			send_to_char( "¿Accesibilidad -opción o +opción?\n\r", ch );
			return;
		}
		if ( !str_prefix( arg+1, "salidas" ) ) bit = PCFLAG_ACC_SALIDAS;
		else if ( !str_prefix( arg+1, "naves"  ) ) bit = PCFLAG_ACC_NAVES;
		else if ( !str_prefix( arg+1, "mobs"  ) ) bit = PCFLAG_ACC_MOBS;
		else if ( !str_prefix( arg+1, "vuelo"  ) ) bit = PCFLAG_ACC_VUELO;
		else if ( !str_prefix( arg+1, "puntuación"  ) ) bit = PCFLAG_ACC_PUNTUACION;
		else {
			send_to_char( "¿Qué opción quieres configurar?\n\r", ch );
			return;
		}
		if ( fSet )
			SET_BIT(ch->pcdata->flags, bit);
		else
			REMOVE_BIT(ch->pcdata->flags, bit);
		send_to_char( "Ok.\n\r", ch );
		return;
	}
}

/*
 * Contributed by Grodyn.
 */
void do_config( CHAR_DATA *ch, const char *argument ) {
	char arg[MAX_INPUT_LENGTH];

	if ( IS_NPC(ch) )
		return;

	one_argument( argument, arg );
	set_char_color( AT_WHITE, ch );
	if ( arg[0] == '\0' ) {
		send_to_char(  "[Palabra clave] Opción\n\r", ch );
		send_to_char(  IS_SET(ch->act, PLR_FLEE)
					 ? "[+HUIDA       ] Huyes si eres atacado.\n\r"
					 : "[-huida       ] Lucharás si eres atacado.\n\r"
					 , ch );
		send_to_char(  IS_SET(ch->pcdata->flags, PCFLAG_NORECALL)
					 ? "[+NORECALL    ] Lucharás hasta la muerte, incluso sin conexión.\n\r"
					 : "[-norecall    ] Tratarás de hacer recall si estás sin conexión.\n\r"
					 , ch );
		send_to_char(  IS_SET(ch->act, PLR_AUTOEXIT)
					 ? "[+AUTOSALIDAS ] Verás las salidas automáticamente.\n\r"
					 : "[-autosalidas ] No verás las salidas automáticamente.\n\r"
					 , ch );
		send_to_char(  IS_SET(ch->act, PLR_AUTOLOOT)
					 ? "[+AUTOSAQ     ] Automáticamente saqueas los cuerpos.\n\r"
					 : "[-autosaq     ] No saqueas automáticamente los cuerpos.\n\r"
					 , ch );
		send_to_char(  IS_SET(ch->act, PLR_AUTOSAC)
					 ? "[+AUTOSAC     ] Automáticamente sacrificas los cuerpos.\n\r"
					 : "[-autosac     ] No sacrificas automáticamente los cuerpos.\n\r"
					 , ch );
		send_to_char(  IS_SET(ch->act, PLR_AUTOGOLD)
					 ? "[+AUTOCRED    ] Repartes el dinero obtenido entre tu grupo.\n\r"
					 : "[-autocred    ] No repartes el dinero obtenido entre tu grupo.\n\r"
					 , ch );
		send_to_char(  IS_SET(ch->pcdata->flags, PCFLAG_GAG)
					 ? "[+GAG         ] Sólo ves el texto necesario en un combate.\n\r"
					 : "[-gag         ] Ves el texto completo del combate.\n\r"
					 , ch );
		send_to_char(  IS_SET(ch->pcdata->flags, PCFLAG_PAGERON)
					 ? "[+PAGINADOR   ] La pantalla se detiene si es muy largo.\n\r"
					 : "[-paginador   ] El mensaje continúa hasta el final.\n\r"
					 , ch );

		send_to_char(  IS_SET(ch->act, PLR_BLANK)
					 ? "[+BLANK       ] Tienes una línea en blanco antes de tu prompt.\n\r"
					 : "[-blank       ] No tienes una línea en blanco antes de tu prompt.\n\r"
					 , ch );
		send_to_char(  IS_SET(ch->act, PLR_BRIEF)
					 ? "[+BREVE       ] Ves descripciones cortas.\n\r"
					 : "[-breve       ] Ves descripciones largas.\n\r"
					 , ch );
		send_to_char(  IS_SET(ch->act, PLR_COMBINE)
					 ? "[+COMBINADO   ] Ves las listas de objetos en formato combinado.\n\r"
					 : "[-combinado   ] Ves las listas de objetos en formato individual.\n\r"
					 , ch );
		send_to_char(  IS_SET(ch->pcdata->flags, PCFLAG_NOINTRO)
					 ? "[+NOINTRO     ] No ves la pantalla de introducción al conectar.\n\r"
					 : "[-nointro     ] Ves la pantalla de introducción al conectar.\n\r"
					 , ch );
		send_to_char(  IS_SET(ch->act, PLR_PROMPT)
					 ? "[+PROMPT      ] Tienes visible el prompt.\n\r"
					 : "[-prompt      ] No tienes visible el prompt.\n\r"
					 , ch );
		send_to_char(  IS_SET(ch->act, PLR_TELNET_GA)
					 ? "[+TELNETGA    ] Recibirás una secuencia de telnet GA.\n\r"
					 : "[-telnetga    ] No recibirás una secuencia de telnet GA.\n\r"
					 , ch );
		send_to_char(  IS_SET(ch->act, PLR_ANSI)
					 ? "[+ANSI        ] Verás secuencias de color ANSI.\n\r"
					 : "[-ansi        ] No verás secuencias de color ANSI.\n\r"
					 , ch );
		send_to_char(  IS_SET(ch->act, PLR_SOUND)
					 ? "[+SONIDO      ] Soportas MSP.\n\r"
					 : "[-sonido      ] No soportas MSP.\n\r"
					 , ch );
		send_to_char(  IS_SET(ch->act, PLR_SHOVEDRAG)
					 ? "[+MOVIDO      ] Permites ser arrastrado y empujado.\n\r"
					 : "[-movido      ] No permites ser arrastrado ni empujado.\n\r"
					 , ch );
		send_to_char(  IS_SET( ch->pcdata->flags, PCFLAG_NOSUMMON )
					 ? "[+NOINVOCAR   ] Otros jugadores NO podrán invocarte.\n\r"
					 : "[-noinvocar   ] El resto de jugadores podrá invocarte.\n\r"
					 , ch );
		send_to_char(  IS_SET( ch->pcdata->flags, PCFLAG_INVREMEMBER )
					 ? "[+INVRECORDAR ] Recordar muestra los mensajes en orden inverso.\n\r"
					 : "[-invrecordar ] Recordar muestra los mensajes en orden normal.\n\r"
					 , ch );
		send_to_char( IS_SET(ch->pcdata->flags, PCFLAG_NOEXP)
					 ? "[+NOEXP       ] No ganas experiencia.\n\r"
					 : "[-noexp       ] Ganas experiencia de forma normal.\n\r", ch);

		if ( IS_IMMORTAL( ch ) )
			send_to_char(  IS_SET(ch->act, PLR_ROOMVNUM)
						 ? "[+VNUM        ] Podrás ver el VNUM de una habitación (Inms).\n\r"
						 : "[-vnum        ] NO verás el VNUM de una habitación.\n\r"
						 , ch );

		if ( IS_IMMORTAL( ch) )             /* Added 10/16 by Kuran of SWR */
			send_to_char( IS_SET(ch->pcdata->flags, PCFLAG_ROOM)
						 ? "[+ROOMFLAGS   ] Te mostrará los flags de room (Inms).\n\r"
						 : "[-roomflags   ] No verás los flags de room.\n\r"
						 , ch );

		send_to_char(  IS_SET(ch->act, PLR_SILENCE)
					 ? "[+SILENCE  ] Estás silenciado.\n\r"
					 : ""
					 , ch );

		send_to_char( !IS_SET(ch->act, PLR_NO_EMOTE)
					 ? ""
					 : "[-emote    ] No puedes hacer emotes.\n\r"
					 , ch );

		send_to_char( !IS_SET(ch->act, PLR_NO_TELL)
					 ? ""
					 : "[-contar     ] No puedes usar el canal 'contar'.\n\r"
					 , ch );

		send_to_char( !IS_SET(ch->act, PLR_LITTERBUG)
					 ? ""
					 : "[-litter  ] A convicted litterbug. No puedes tirar nada.\n\r"
					 , ch );

		send_to_char( !IS_SET(ch->act, PLR_NO_NOVEL)
					 ? ""
					 : "[-novel  ] No puedes usar el canal 'novel'.\n\r"
					 , ch );
	}
	else
	{
		bool fSet;
		int bit = 0;

		if ( arg[0] == '+' ) fSet = TRUE;
		else if ( arg[0] == '-' ) fSet = FALSE;
		else
		{
			send_to_char( "¿Config -opción o +opción?\n\r", ch );
			return;
		}

		if ( !str_prefix( arg+1, "autosalidas" ) ) bit = PLR_AUTOEXIT;
		else if ( !str_prefix( arg+1, "autosaq" ) ) bit = PLR_AUTOLOOT;
		else if ( !str_prefix( arg+1, "autosac"  ) ) bit = PLR_AUTOSAC;
		else if ( !str_prefix( arg+1, "autocred" ) ) bit = PLR_AUTOGOLD;
		else if ( !str_prefix( arg+1, "blank"    ) ) bit = PLR_BLANK;
		else if ( !str_prefix( arg+1, "breve"    ) ) bit = PLR_BRIEF;
		else if ( !str_prefix( arg+1, "combinado"  ) ) bit = PLR_COMBINE;
		else if ( !str_prefix( arg+1, "prompt"   ) ) bit = PLR_PROMPT;
		else if ( !str_prefix( arg+1, "telnetga" ) ) bit = PLR_TELNET_GA;
		else if ( !str_prefix( arg+1, "ansi"     ) ) bit = PLR_ANSI;
		else if ( !str_prefix( arg+1, "sonido"      ) ) bit = PLR_SOUND;
		else if ( !str_prefix( arg+1, "huida"     ) ) bit = PLR_FLEE;
		else if ( !str_prefix( arg+1, "bueno"     ) ) bit = PLR_NICE;
		else if ( !str_prefix( arg+1, "movido") ) bit = PLR_SHOVEDRAG;
		else if ( IS_IMMORTAL( ch )
				 &&   !str_prefix( arg+1, "vnum"     ) ) bit = PLR_ROOMVNUM;

		if (bit)
		{

			if ( fSet )
				SET_BIT    (ch->act, bit);
			else
				REMOVE_BIT (ch->act, bit);
			send_to_char( "Ok.\n\r", ch );
			return;
		}
		else
		{
			if ( !str_prefix( arg+1, "norecall" ) ) bit = PCFLAG_NORECALL;
			else if ( !str_prefix( arg+1, "nointro"  ) ) bit = PCFLAG_NOINTRO;
			else if ( !str_prefix( arg+1, "noinvocar" ) ) bit = PCFLAG_NOSUMMON;
			else if ( !str_prefix( arg+1, "gag"      ) ) bit = PCFLAG_GAG;
			else if ( !str_prefix( arg+1, "paginador"    ) ) bit = PCFLAG_PAGERON;
			else if ( !str_prefix( arg+1, "invrecordar")) bit = PCFLAG_INVREMEMBER;
			else if ( !str_prefix( arg+1, "noexp")) bit = PCFLAG_NOEXP;
			else if ( !str_prefix( arg+1, "roomflags")
					 && (IS_IMMORTAL(ch))) bit = PCFLAG_ROOM;
			else
			{
				send_to_char( "¿Qué opción quieres configurar?\n\r", ch );
				return;
			}

			if ( fSet )
				SET_BIT    (ch->pcdata->flags, bit);
			else
				REMOVE_BIT (ch->pcdata->flags, bit);

			send_to_char( "Ok.\n\r", ch );
			return;
		}
	}

	return;
}

extern int top_area;

/*
void do_areas( CHAR_DATA *ch, char *argument )
{
    AREA_DATA *pArea1;
    AREA_DATA *pArea2;
    int iArea;
    int iAreaHalf;

    iAreaHalf = (top_area + 1) / 2;
    pArea1    = first_area;
    pArea2    = first_area;
    for ( iArea = 0; iArea < iAreaHalf; iArea++ )
	pArea2 = pArea2->next;

    for ( iArea = 0; iArea < iAreaHalf; iArea++ )
    {
	ch_printf( ch, "%-39s%-39s\n\r",
	    pArea1->name, pArea2 ? pArea2->name : "" );
	pArea1 = pArea1->next;
	if ( pArea2 )
	    pArea2 = pArea2->next;
    }

    return;
}
*/

/*
 * New do_areas with soft/hard level ranges
 */

void do_areas( CHAR_DATA *ch, const char *argument )
{
    AREA_DATA *pArea;

    set_pager_color( AT_PLAIN, ch );
    send_to_pager("\n\r   Autor     |             Area                     | Recomendado |  Necesario\n\r", ch);
    send_to_pager("-------------+--------------------------------------+-------------+------------\n\r", ch);

    for ( pArea = first_area; pArea; pArea = pArea->next )
		if (!IS_SET(pArea->flags, AFLAG_NOSHOW))
			pager_printf(ch, "%-12s | %-36s | %4d - %-4d | %3d - %-3d \n\r",
	 			pArea->author, pArea->name, pArea->low_soft_range,
				pArea->hi_soft_range, pArea->low_hard_range,
				pArea->hi_hard_range);
    return;
}

void do_afk( CHAR_DATA *ch, const char *argument )
{
     if ( IS_NPC(ch) )
     return;

     if IS_SET(ch->act, PLR_AFK)
     {
    	REMOVE_BIT(ch->act, PLR_AFK);
	send_to_char( "Ya no estás afk.\n\r", ch );
	act(AT_GREY,"$n ya no está afk.", ch, NULL, NULL, TO_ROOM);
     }
     else
     {
	SET_BIT(ch->act, PLR_AFK);
	send_to_char( "Ahora estás afk.\n\r", ch );
	act(AT_GREY,"$n está afk.", ch, NULL, NULL, TO_ROOM);
	return;
     }

}

void do_slist( CHAR_DATA *ch, const char *argument )
{
	int sn, i, lFound;
	char skn[MAX_INPUT_LENGTH];
	char arg1[MAX_INPUT_LENGTH];
	char arg2[MAX_INPUT_LENGTH];
	int lowlev, hilev;
	int col = 0;
	int ability;

	if ( IS_NPC(ch) )
		return;

	argument = one_argument( argument, arg1 );
	argument = one_argument( argument, arg2 );

	lowlev=1;
	hilev=100;

	if (arg1[0]!='\0')
		lowlev=atoi(arg1);

	if ((lowlev<1) || (lowlev>LEVEL_IMMORTAL))
		lowlev=1;

	if (arg2[0]!='\0')
		hilev=atoi(arg2);

	if ((hilev<0) || (hilev>=LEVEL_IMMORTAL))
		hilev=LEVEL_HERO;

	if(lowlev>hilev)
		lowlev=hilev;

	set_pager_color( AT_MAGIC, ch );
	send_to_pager("  CONOCIMIENTOS\n\r",ch);
	send_to_pager("------------------\n\r",ch);

	for ( ability = -1 ; ability < MAX_ABILITY ; ability++ )
	{
		//   if ( ability == FORCE_ABILITY )
		//      continue;

		if ( ability >= 0 )
			sprintf(skn, "\n\r%s\n\r", ability_name[ability] );
		else
			sprintf(skn, "\n\rHabilidades Generales\n\r" );

		send_to_pager(skn,ch);
		for (i=lowlev	; i <= hilev; i++)
		{
			lFound= 0;
			for ( sn = 0; sn < top_sn; sn++ )
			{
				if ( !skill_table[sn]->name )
					break;

				if ( skill_table[sn]->skill_level[ability] == 0)
					continue;

				if ( ch->pcdata->learned[sn] == 0
				    &&   SPELL_FLAG(skill_table[sn], SF_SECRETSKILL) )
					continue;

				if(i==skill_table[sn]->skill_level[ability])
				{
					pager_printf(ch, "(%3d) %-18.18s  ",
					             i,  skill_table[sn]->name );
					if ( ++col == 3 )
					{
						pager_printf(ch, "\n\r");
						col = 0;
					}
				}
			}
		}
		if ( col != 0 )
		{
			pager_printf(ch, "\n\r");
			col = 0;
		}
	}
	return;
}

void do_whois( CHAR_DATA *ch, const char *argument)
{
	CHAR_DATA *victim;
	char buf[MAX_STRING_LENGTH];
	char buf2[MAX_STRING_LENGTH];
	int i;
	char *top_ability = NULL;

	buf[0] = '\0';

	if(IS_NPC(ch))
		return;

	if(argument[0] == '\0')
	{
		send_to_char("Debes introducir el nombre de un jugador conectado.\n\r", ch);
		return;
	}

	strcat(buf, "0.");
	strcat(buf, argument);
	if( ( ( victim = get_char_world(ch, buf) ) == NULL ))
	{
		send_to_char("Ese jugador no está conectado.\n\r", ch);
		return;
	}

	if(IS_NPC(victim))
	{
		send_to_char("¡Ese no es un jugador!\n\r", ch);
		return;
	}

	//ch_printf(ch, "%s es un %s de nivel %d %s", victim->name, victim->sex == SEX_MALE ? "es un varón" : victim->sex == SEX_FEMALE ?
	//		  "una mujer" : "neutral", victim->top_level, npc_race[victim->race]);
	ch_printf(ch, "%s es un miembro de la especie %s de género %s", victim->name, npc_race[victim->race],
			  victim->sex == SEX_MALE? "masculino" : victim->sex == SEX_FEMALE? "femenino" : "neutral");
	if (IS_IMMORTAL(ch)) {
		for (i=0; i<MAX_ABILITY; i++) {
			if (victim->skill_level[i] == victim->top_level) {
				top_ability = ability_name[i];
				break;
			}
		}
		ch_printf(ch, " de nivel %d en categoría %s en la habitación %d.\n\r", victim->top_level, top_ability?top_ability:"-",
				  victim->in_room->vnum);
	} else
		ch_printf(ch, ".\n\r");

	if ( victim->pcdata->clan )
	{
		if ( victim->pcdata->clan->clan_type == CLAN_CRIME )
			send_to_char( ", y pertenece a la familia criminal ", ch );
		else if ( victim->pcdata->clan->clan_type == CLAN_GUILD )
			send_to_char( ", y pertenece al gremio ", ch );
		else
			send_to_char( ", y pertenece a la organización ", ch );
		send_to_char( victim->pcdata->clan->name, ch );
	}
	send_to_char( ".\n\r", ch );

	if(victim->pcdata->homepage && victim->pcdata->homepage[0] != '\0')
		ch_printf(ch, "Su página web es: %s.\n\r",
				  victim->name,
				  victim->pcdata->homepage);

	if(victim->pcdata->bio && victim->pcdata->bio[0] != '\0')
		ch_printf(ch, "Datos Biográficos de %s:\n\r%s",
				  victim->name,
				  victim->pcdata->bio);

	if(IS_IMMORTAL(ch))
	{
		send_to_char("----------------------------------------------------\n\r", ch);

		send_to_char("Info para inmortales:\n\r", ch);

		if ( victim->pcdata->authed_by && victim->pcdata->authed_by[0] != '\0' )
			ch_printf(ch, "%s fue autorizado por %s.\n\r",
					  victim->name, victim->pcdata->authed_by);

		ch_printf(ch, "%s ha matado %d mobs, y ha muerto a manos de mobs %d veces.\n\r",
				  victim->name, victim->pcdata->mkills, victim->pcdata->mdeaths );
		if ( victim->pcdata->pkills || victim->pcdata->pdeaths )
			ch_printf(ch, "%s ha matado %d jugadores, y ha muerto a manos de jugadores %d veces.\n\r",
					  victim->name, victim->pcdata->pkills, victim->pcdata->pdeaths );
		if ( victim->pcdata->illegal_pk )
			ch_printf(ch, "%s ha cometido %d asesinatos ilegales de jugadores.\n\r",
					  victim->name, victim->pcdata->illegal_pk );

		ch_printf(ch, "%s %sestá condenado en este momento.\n\r",
				  victim->name,
				  (victim->pcdata->release_date == 0) ? "no " : "");

		if(victim->pcdata->release_date != 0)
			ch_printf(ch, "%s fue  condenado al infierno por %s, y regresará el %24.24s.\n\r",
					  victim->sex == SEX_MALE ? "él" :
						  victim->sex == SEX_FEMALE ? "Ella" : "Él",
						  victim->pcdata->helled_by,
						  ctime(&victim->pcdata->release_date));

		if(get_trust(victim) < get_trust(ch))
		{
			sprintf(buf2, "lista %s", buf);
			do_comment(ch, buf2);
		}

		if(IS_SET(victim->act, PLR_SILENCE) || IS_SET(victim->act, PLR_NO_EMOTE)
		   || IS_SET(victim->act, PLR_NO_TELL) )
		{
			sprintf(buf2, "Tiene los flags:");
			if(IS_SET(victim->act, PLR_SILENCE))
				strcat(buf2, " silenciado");
			if(IS_SET(victim->act, PLR_NO_EMOTE))
				strcat(buf2, " noemote");
			if(IS_SET(victim->act, PLR_NO_TELL) )
				strcat(buf2, " nocontar");
			if(IS_SET(victim->act, PLR_NO_NOVEL) )
				strcat(buf2, " nonovel");
			strcat(buf2, ".\n\r");
			send_to_char(buf2, ch);
		}
		if ( victim->desc && victim->desc->host[0]!='\0' )   /* added by Gorog */
		{
			sprintf (buf2, "%s's IP info: %s ", victim->name, victim->desc->hostip);
			if (get_trust(ch) >= LEVEL_GOD)
			{
				strcat (buf2, victim->desc->host);
			}
			strcat (buf2, "\n\r");
			send_to_char(buf2, ch);
		}
	}
}

void do_pager( CHAR_DATA *ch, const char *argument )
{
  char arg[MAX_INPUT_LENGTH];

  if ( IS_NPC(ch) )
    return;
  argument = one_argument(argument, arg);
  if ( !*arg )
  {
    if ( IS_SET(ch->pcdata->flags, PCFLAG_PAGERON) )
      do_config(ch, "-paginador");
    else
      do_config(ch, "+paginador");
    return;
  }
  if ( !is_number(arg) )
  {
    send_to_char( "¿En cuántas líneas debe detenerse la página?\n\r", ch );
    return;
  }
  ch->pcdata->pagerlen = atoi(arg);
  if ( ch->pcdata->pagerlen < 5 )
    ch->pcdata->pagerlen = 5;
  ch_printf( ch, "Pausa de página establecida en %d líneas.\n\r", ch->pcdata->pagerlen );
  return;
}
